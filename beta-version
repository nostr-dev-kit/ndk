#!/bin/bash

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check if beta number argument is provided
if [ -z "$1" ]; then
    echo -e "${RED}Error: Beta version number required${NC}"
    echo "Usage: ./beta-version <beta-number>"
    echo "Example: ./beta-version 20"
    exit 1
fi

BETA_NUM=$1

# Validate that the argument is a number
if ! [[ "$BETA_NUM" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error: Beta version must be a number${NC}"
    exit 1
fi

echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  NDK Beta Version Bump to beta.${BETA_NUM}${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq"
    exit 1
fi

# Define all workspace packages
PACKAGES=(
    "core"
    "svelte"
    "react"
    "mobile"
    "wallet"
    "blossom"
    "cache-dexie"
    "cache-memory"
    "cache-redis"
    "cache-nostr"
    "cache-sqlite"
    "cache-sqlite-wasm"
    "messages"
    "sessions"
    "sync"
    "wot"
)

# Array to store version info for display
declare -a VERSION_INFO

echo -e "${YELLOW}Step 1: Updating package versions...${NC}"

# First pass: Update all package versions
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        echo -e "${RED}Warning: $PKG_JSON not found, skipping${NC}"
        continue
    fi

    # Get current version
    CURRENT_VERSION=$(jq -r '.version' "$PKG_JSON")

    # Extract base version (everything before -beta)
    BASE_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/-beta\.[0-9]+$//')

    # If no beta suffix exists, use the version as is
    if [[ "$CURRENT_VERSION" == "$BASE_VERSION" ]]; then
        BASE_VERSION="$CURRENT_VERSION"
    fi

    # Create new version
    NEW_VERSION="${BASE_VERSION}-beta.${BETA_NUM}"

    # Update package.json
    jq --arg version "$NEW_VERSION" '.version = $version' "$PKG_JSON" > "${PKG_JSON}.tmp"
    mv "${PKG_JSON}.tmp" "$PKG_JSON"

    # Store info for display
    VERSION_INFO+=("${pkg}|${CURRENT_VERSION}|${NEW_VERSION}")

    echo -e "  ${GREEN}✓${NC} ${pkg}: ${CURRENT_VERSION} → ${NEW_VERSION}"
done

echo ""
echo -e "${YELLOW}Step 2: Updating internal dependencies...${NC}"

# Second pass: Update all internal @nostr-dev-kit dependencies
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        continue
    fi

    # Get package name
    PKG_NAME=$(jq -r '.name' "$PKG_JSON")

    # Update dependencies, devDependencies, and peerDependencies
    for dep_type in "dependencies" "devDependencies" "peerDependencies"; do
        # Get all @nostr-dev-kit dependencies
        NDK_DEPS=$(jq -r ".${dep_type} // {} | keys[] | select(startswith(\"@nostr-dev-kit/\"))" "$PKG_JSON" 2>/dev/null || true)

        if [ -n "$NDK_DEPS" ]; then
            while IFS= read -r dep_name; do
                # Find the package directory for this dependency
                for dep_pkg in "${PACKAGES[@]}"; do
                    DEP_PKG_JSON="${dep_pkg}/package.json"
                    if [ -f "$DEP_PKG_JSON" ]; then
                        DEP_PKG_NAME=$(jq -r '.name' "$DEP_PKG_JSON")
                        if [ "$DEP_PKG_NAME" == "$dep_name" ]; then
                            # Get the new version for this dependency
                            DEP_NEW_VERSION=$(jq -r '.version' "$DEP_PKG_JSON")

                            # Update the dependency version
                            jq --arg dep "$dep_name" --arg version "$DEP_NEW_VERSION" \
                                ".${dep_type}[\$dep] = \$version" "$PKG_JSON" > "${PKG_JSON}.tmp"
                            mv "${PKG_JSON}.tmp" "$PKG_JSON"

                            echo -e "  ${GREEN}✓${NC} ${pkg}: ${dep_name} → ${DEP_NEW_VERSION} (${dep_type})"
                            break
                        fi
                    fi
                done
            done <<< "$NDK_DEPS"
        fi
    done
done

echo ""
echo -e "${YELLOW}Step 3: Running syncpack to verify consistency...${NC}"
bun cs:check || {
    echo -e "${YELLOW}Running syncpack fix-mismatches...${NC}"
    bunx syncpack fix-mismatches
}

echo ""
echo -e "${YELLOW}Step 4: Updating app dependencies...${NC}"

# Find all package.json files that aren't part of main packages
APP_PACKAGES=()
while IFS= read -r pkg_json; do
    # Extract directory path
    dir=$(dirname "$pkg_json")

    # Normalize path by removing leading ./
    normalized_path="${pkg_json#./}"

    # Skip if it's one of the main packages or root
    skip=false
    for main_pkg in "${PACKAGES[@]}"; do
        if [[ "$normalized_path" == "${main_pkg}/package.json" ]] || [[ "$normalized_path" == "package.json" ]]; then
            skip=true
            break
        fi
    done

    if [ "$skip" = false ]; then
        APP_PACKAGES+=("$dir")
    fi
done < <(find . -name "package.json" -not -path "*/node_modules/*" -not -path "*/.turbo/*" -not -path "*/dist/*")

if [ ${#APP_PACKAGES[@]} -gt 0 ]; then
    echo -e "${BLUE}Found ${#APP_PACKAGES[@]} app(s)/example(s) with package.json${NC}"

    for app_dir in "${APP_PACKAGES[@]}"; do
        PKG_JSON="${app_dir}/package.json"

        if [ ! -f "$PKG_JSON" ]; then
            continue
        fi

        # Check if this package.json has any @nostr-dev-kit dependencies
        NDK_DEPS=$(jq -r '[
            (.dependencies // {} | to_entries[]),
            (.devDependencies // {} | to_entries[]),
            (.peerDependencies // {} | to_entries[])
        ] | map(select(.key | startswith("@nostr-dev-kit/"))) | .[] | "\(.key)|\(.value)"' "$PKG_JSON" 2>/dev/null || true)

        if [ -z "$NDK_DEPS" ]; then
            continue
        fi

        echo ""
        echo -e "${BLUE}Checking: ${app_dir}${NC}"

        UPDATED=false

        while IFS='|' read -r dep_name dep_version; do
            # Skip workspace:* references only
            if [[ "$dep_version" == "workspace:"* ]]; then
                echo -e "  ${GREEN}✓${NC} ${dep_name}: ${dep_version} (workspace reference, skipping)"
                continue
            fi

            # Find the corresponding package to get the new version
            NEW_VERSION=""
            for pkg in "${PACKAGES[@]}"; do
                PKG_PKG_JSON="${pkg}/package.json"
                if [ -f "$PKG_PKG_JSON" ]; then
                    PKG_NAME=$(jq -r '.name' "$PKG_PKG_JSON")
                    if [ "$PKG_NAME" == "$dep_name" ]; then
                        NEW_VERSION=$(jq -r '.version' "$PKG_PKG_JSON")
                        break
                    fi
                fi
            done

            # If we found a matching package, update the dependency
            if [ -n "$NEW_VERSION" ]; then
                for dep_type in "dependencies" "devDependencies" "peerDependencies"; do
                    if jq -e ".${dep_type}.\"${dep_name}\"" "$PKG_JSON" > /dev/null 2>&1; then
                        jq --arg dep "$dep_name" --arg version "$NEW_VERSION" \
                            ".${dep_type}[\$dep] = \$version" "$PKG_JSON" > "${PKG_JSON}.tmp"
                        mv "${PKG_JSON}.tmp" "$PKG_JSON"
                        echo -e "  ${GREEN}✓${NC} Updated ${dep_name}: ${dep_version} → ${NEW_VERSION}"
                        UPDATED=true
                    fi
                done
            else
                echo -e "  ${YELLOW}⚠${NC} ${dep_name}: ${dep_version} (no matching package found)"
            fi
        done <<< "$NDK_DEPS"
    done
fi

echo ""
echo -e "${YELLOW}Step 5: Fixing package.json errors...${NC}"
for pkg in "${PACKAGES[@]}"; do
    if [ -d "$pkg" ]; then
        (cd "$pkg" && npm pkg fix) 2>/dev/null
        echo -e "  ${GREEN}✓${NC} Fixed ${pkg}/package.json"
    fi
done

echo ""
echo -e "${YELLOW}Step 6: Building all packages...${NC}"
bun run build:libs

echo ""
echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  Version Summary (beta.${BETA_NUM})${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""
printf "%-30s %-25s %-25s\n" "Package" "Old Version" "New Version"
printf "%-30s %-25s %-25s\n" "-------" "-----------" "-----------"

for info in "${VERSION_INFO[@]}"; do
    IFS='|' read -r pkg old new <<< "$info"
    printf "%-30s %-25s %-25s\n" "$pkg" "$old" "$new"
done

echo ""
echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  Internal Dependencies${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""

# Show internal dependencies for each package
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        continue
    fi

    PKG_NAME=$(jq -r '.name' "$PKG_JSON")
    HAS_DEPS=false

    # Check all dependency types
    for dep_type in "dependencies" "devDependencies" "peerDependencies"; do
        NDK_DEPS=$(jq -r ".${dep_type} // {} | to_entries[] | select(.key | startswith(\"@nostr-dev-kit/\")) | \"\(.key)@\(.value)\"" "$PKG_JSON" 2>/dev/null || true)

        if [ -n "$NDK_DEPS" ]; then
            if [ "$HAS_DEPS" = false ]; then
                echo -e "${GREEN}${pkg}${NC} (${PKG_NAME}):"
                HAS_DEPS=true
            fi

            while IFS= read -r dep; do
                echo "  - $dep"
            done <<< "$NDK_DEPS"
        fi
    done

    if [ "$HAS_DEPS" = true ]; then
        echo ""
    fi
done

echo -e "${YELLOW}Step 7: Committing changes...${NC}"
git add -A
git commit -m "chore: bump to beta.${BETA_NUM}"
echo -e "${GREEN}✓ Changes committed${NC}"

echo ""
echo -e "${YELLOW}Step 8: Publishing to npm with beta tag...${NC}"
echo ""

read -p "Continue with publish? (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    for pkg in "${PACKAGES[@]}"; do
        if [ -d "$pkg" ]; then
            echo -e "${BLUE}Publishing ${pkg}...${NC}"
            (cd "$pkg" && npm publish --tag beta --otp $(2fa npm))
            echo -e "${GREEN}✓ Published ${pkg}${NC}"
        fi
    done
    echo ""
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}  ✓ Successfully published beta.${BETA_NUM}${NC}"
    echo -e "${GREEN}================================================${NC}"
else
    echo -e "${YELLOW}Publish cancelled. You can publish later by running:${NC}"
    echo -e "${BLUE}  cd <package> && npm publish --tag beta --otp \$(2fa npm)${NC}"
fi
