#!/bin/bash

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check if beta number argument is provided
if [ -z "$1" ]; then
    echo -e "${RED}Error: Beta version number required${NC}"
    echo "Usage: ./beta-version <beta-number>"
    echo "Example: ./beta-version 20"
    exit 1
fi

BETA_NUM=$1

# Validate that the argument is a number
if ! [[ "$BETA_NUM" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error: Beta version must be a number${NC}"
    exit 1
fi

echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  NDK Beta Version Bump to beta.${BETA_NUM}${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq"
    exit 1
fi

# Define all workspace packages
PACKAGES=(
    "core"
    "svelte"
    "react"
    "mobile"
    "wallet"
    "blossom"
    "cache-dexie"
    "cache-memory"
    "cache-redis"
    "cache-nostr"
    "cache-sqlite"
    "cache-sqlite-wasm"
    "messages"
    "sessions"
    "sync"
    "wot"
)

# Array to store version info for display
declare -a VERSION_INFO

echo -e "${YELLOW}Step 1: Updating package versions...${NC}"

# First pass: Update all package versions
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        echo -e "${RED}Warning: $PKG_JSON not found, skipping${NC}"
        continue
    fi

    # Get current version
    CURRENT_VERSION=$(jq -r '.version' "$PKG_JSON")

    # Extract base version (everything before -beta)
    BASE_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/-beta\.[0-9]+$//')

    # If no beta suffix exists, use the version as is
    if [[ "$CURRENT_VERSION" == "$BASE_VERSION" ]]; then
        BASE_VERSION="$CURRENT_VERSION"
    fi

    # Create new version
    NEW_VERSION="${BASE_VERSION}-beta.${BETA_NUM}"

    # Update package.json
    jq --arg version "$NEW_VERSION" '.version = $version' "$PKG_JSON" > "${PKG_JSON}.tmp"
    mv "${PKG_JSON}.tmp" "$PKG_JSON"

    # Store info for display
    VERSION_INFO+=("${pkg}|${CURRENT_VERSION}|${NEW_VERSION}")

    echo -e "  ${GREEN}✓${NC} ${pkg}: ${CURRENT_VERSION} → ${NEW_VERSION}"
done

echo ""
echo -e "${YELLOW}Step 2: Updating internal dependencies...${NC}"

# Second pass: Update all internal @nostr-dev-kit dependencies
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        continue
    fi

    # Get package name
    PKG_NAME=$(jq -r '.name' "$PKG_JSON")

    # Update dependencies, devDependencies, and peerDependencies
    for dep_type in "dependencies" "devDependencies" "peerDependencies"; do
        # Get all @nostr-dev-kit dependencies
        NDK_DEPS=$(jq -r ".${dep_type} // {} | keys[] | select(startswith(\"@nostr-dev-kit/\"))" "$PKG_JSON" 2>/dev/null || true)

        if [ -n "$NDK_DEPS" ]; then
            while IFS= read -r dep_name; do
                # Find the package directory for this dependency
                for dep_pkg in "${PACKAGES[@]}"; do
                    DEP_PKG_JSON="${dep_pkg}/package.json"
                    if [ -f "$DEP_PKG_JSON" ]; then
                        DEP_PKG_NAME=$(jq -r '.name' "$DEP_PKG_JSON")
                        if [ "$DEP_PKG_NAME" == "$dep_name" ]; then
                            # Get the new version for this dependency
                            DEP_NEW_VERSION=$(jq -r '.version' "$DEP_PKG_JSON")

                            # Update the dependency version
                            jq --arg dep "$dep_name" --arg version "$DEP_NEW_VERSION" \
                                ".${dep_type}[\$dep] = \$version" "$PKG_JSON" > "${PKG_JSON}.tmp"
                            mv "${PKG_JSON}.tmp" "$PKG_JSON"

                            echo -e "  ${GREEN}✓${NC} ${pkg}: ${dep_name} → ${DEP_NEW_VERSION} (${dep_type})"
                            break
                        fi
                    fi
                done
            done <<< "$NDK_DEPS"
        fi
    done
done

echo ""
echo -e "${YELLOW}Step 3: Running syncpack to verify consistency...${NC}"
bun cs:check || {
    echo -e "${YELLOW}Running syncpack fix-mismatches...${NC}"
    bunx syncpack fix-mismatches
}

echo ""
echo -e "${YELLOW}Step 4: Building all packages...${NC}"
bun run build:libs

echo ""
echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  Version Summary (beta.${BETA_NUM})${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""
printf "%-30s %-25s %-25s\n" "Package" "Old Version" "New Version"
printf "%-30s %-25s %-25s\n" "-------" "-----------" "-----------"

for info in "${VERSION_INFO[@]}"; do
    IFS='|' read -r pkg old new <<< "$info"
    printf "%-30s %-25s %-25s\n" "$pkg" "$old" "$new"
done

echo ""
echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}  Internal Dependencies${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""

# Show internal dependencies for each package
for pkg in "${PACKAGES[@]}"; do
    PKG_JSON="${pkg}/package.json"

    if [ ! -f "$PKG_JSON" ]; then
        continue
    fi

    PKG_NAME=$(jq -r '.name' "$PKG_JSON")
    HAS_DEPS=false

    # Check all dependency types
    for dep_type in "dependencies" "devDependencies" "peerDependencies"; do
        NDK_DEPS=$(jq -r ".${dep_type} // {} | to_entries[] | select(.key | startswith(\"@nostr-dev-kit/\")) | \"\(.key)@\(.value)\"" "$PKG_JSON" 2>/dev/null || true)

        if [ -n "$NDK_DEPS" ]; then
            if [ "$HAS_DEPS" = false ]; then
                echo -e "${GREEN}${pkg}${NC} (${PKG_NAME}):"
                HAS_DEPS=true
            fi

            while IFS= read -r dep; do
                echo "  - $dep"
            done <<< "$NDK_DEPS"
        fi
    done

    if [ "$HAS_DEPS" = true ]; then
        echo ""
    fi
done

echo -e "${YELLOW}Step 5: Committing changes...${NC}"
git add -A
git commit -m "chore: bump to beta.${BETA_NUM}"
echo -e "${GREEN}✓ Changes committed${NC}"

echo ""
echo -e "${YELLOW}Step 6: Publishing to npm with beta tag...${NC}"
echo ""

read -p "Continue with publish? (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    for pkg in "${PACKAGES[@]}"; do
        if [ -d "$pkg" ]; then
            echo -e "${BLUE}Publishing ${pkg}...${NC}"
            (cd "$pkg" && npm publish --tag beta --otp $(2fa npm))
            echo -e "${GREEN}✓ Published ${pkg}${NC}"
        fi
    done
    echo ""
    echo -e "${GREEN}================================================${NC}"
    echo -e "${GREEN}  ✓ Successfully published beta.${BETA_NUM}${NC}"
    echo -e "${GREEN}================================================${NC}"
else
    echo -e "${YELLOW}Publish cancelled. You can publish later by running:${NC}"
    echo -e "${BLUE}  cd <package> && npm publish --tag beta --otp \$(2fa npm)${NC}"
fi
