# Signers

All events on the Nostr protocol are signed through a keypair
(described in [NIP-01](https://github.com/nostr-protocol/nips/blob/master/01.md#events-and-signatures)).

In NDK this is taken care of by the `NDKSigner` interface that can be passed in during initialization or later during
runtime.

## Signing Methods

Before you can sign events you need a signer set-up. There are different ways to sign events and this space is still
evolving.

### Browser Extensions

A common way to use NDK is to use a browser extension which is described
in [NIP-07](https://github.com/nostr-protocol/nips/blob/master/07.md).
This mechanism allows the user to sign events with a browser extension to not share their private key with the
application.

The most used browser extensions are [Nos2x](https://github.com/fiatjaf/nos2x)
and [Alby](https://getalby.com/alby-extension).

<<< @/core/docs/snippets/sign_event.ts

Anytime you call `sign()` or `publish()` on an [NDK Event](/core/docs/fundamentals/events.html) the browser
extension will prompt the user to sign the event.

### Private Key Signer

NDK provides `NDKPrivateKeySigner` for managing in-memory private keys. This is useful for development, testing, or
applications that manage keys locally.

> [!WARNING]
> We strongly recommend not using this in production. Requiring users to share their private key is a security
> risk and should be avoided in favor of
> using [a browser extension](/core/docs/fundamentals/signers.html#browser-extensions)
> or [a remote signer](/core/docs/fundamentals/signers.html#remote-signer).

The private key signer takes the private key in the `nsec` format.

<<< @/core/docs/snippets/sign_event_nsec.ts

This library can also [help with generating new keys](/core/docs/fundamentals/signers.html#generate-keys).

### Remote Signer

A Nostr remote signer (aka `bunker`) is an application or device that securely stores your private key and signs Nostr
events on your behalf, preventing you from having to expose the private key. It works by establishing a secure
connection (over
Nostr relays), as described in [NIP-46](https://github.com/nostr-protocol/nips/blob/master/46.md), where the bunker
implementation can approve or deny requests.

To add remote signing support to your application, there are a few things you need:

* a bunker:// connection string provided by the user
* A local (client) keypair used to communicate with
  remote-signer. [Can be generated by NDK](/core/docs/fundamentals/signers.html#generate-keys)

Create a `NDKNip46Signer` with the bunker connection string and local keypair.

<<< @/core/docs/snippets/sign_with_bunker.ts

## Sign Events

Once the signer is initialized, you can use it to sign and [publish](/core/docs/fundamentals/publishing.html) events:

<<< @/core/docs/snippets/sign_event.ts

## Signer Relays

If the [signer](/core/docs/fundamentals/signers.md) implements the `getRelays()` method,
NDK will use the relays returned by that method as the explicit relays.

## Combining signers

You can specify the use of a different signer to sign with different keys.

> [!TIP]
> If you plan on allowing multiple signers we recommend using [@nostr-dev-kit/sessions](/sessions/README.html).

<<< @/core/docs/snippets/sign_event_with_other_signers.ts

## Read Public key

**Read the user's public key**

```ts
nip07signer.user().then(async (user) => {
    if (!!user.npub) {
        console.log("Permission granted to read their public key:", user.npub);
    }
});
```

## Generate Keys

One good case where you would want to use `NDKPrivateKeySigner` is to help you generate keys as the signer
provides helper methods.

This snippet demonstrates how to generate a new key pair and obtain all its various formats (private key, public key,
nsec, npub).

<<< @/core/docs/snippets/key_create.ts

You can use these different formats for different purposes:

- `privateKey`: Raw private key for cryptographic operations
- `publicKey`: Raw public key (hex format) for verification
- `nsec`: Encoded private key format (bech32) - used for secure sharing when needed
- `npub`: Encoded public key format (bech32) - used for user identification

### Storing Keys

For storing keys securely with password protection,
use [NIP-49](https://github.com/nostr-protocol/nips/blob/master/49.md) (ncryptsec format):

<<< @/core/docs/snippets/key_create_store.ts

See [Encrypted Keys (NIP-49)](./encrypted-keys-nip49.md) for more examples and best practices.

## Code Snippets

More snippets and examples can be found in the [snippets directory](/docs/snippets.md#signers)