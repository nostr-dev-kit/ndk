This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-31T21:05:10.782Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  ndk-examples.md
  ndk-hooks.md
  subscribe.md
examples/
  ndk-demo.tsx
  profile-demo.tsx
  subscribe-example.tsx
src/
  hooks/
    current-user.ts
    ndk.ts
    profile.ts
    subscribe.ts
  stores/
    profiles/
      fetch-profile.ts
      index.ts
      iniitialize.ts
      initialize.ts
      set-profile.ts
    ndk.ts
    subscribe.ts
  utils/
    time.ts
  index.ts
test/
  hooks/
    current-user.test.ts
    ndk.test.ts
    profile.test.ts
  stores/
    ndk.test.ts
    profiles.test.ts
  setup.ts
  subscribe.test.ts
.biomeignore
.gitignore
.roomodes
biome.json
package.json
README.md
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/ndk-examples.md">
# NDK Store and Hooks - Examples

This document provides practical examples for using the NDK store and hooks in your React applications.

## Basic NDK Demo

The following example demonstrates how to:
- Initialize an NDK instance
- Set it in the store using useNDK
- Access and use the current user with useNDKCurrentUser
- Handle the 'signer:ready' event

```tsx
import React, { useEffect, useState } from 'react';
import NDK, { NDKNip07Signer } from '@nostr-dev-kit/ndk';
import { useNDK, useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks';

function NDKDemo() {
  const { ndk, setNDK } = useNDK();
  const { currentUser, setCurrentUser } = useNDKCurrentUser();
  const [status, setStatus] = useState('Initializing');
  
  // Initialize NDK on component mount
  useEffect(() => {
    const initializeNDK = async () => {
      try {
        // Create a new NDK instance with a browser extension signer
        const signer = new NDKNip07Signer();
        const ndkInstance = new NDK({
          explicitRelayUrls: [
            'wss://relay.nostr.band',
            'wss://relay.damus.io',
            'wss://nos.lol',
          ],
          signer,
        });
        
        // Listen for signer:ready event explicitly (for demo purposes)
        ndkInstance.on('signer:ready', () => {
          setStatus('Signer ready');
          // Note: currentUser will be automatically set by the store's event handler
          // This is just to demonstrate the event flow
        });
        
        // Connect to relays
        await ndkInstance.connect();
        setStatus('Connected to relays');
        
        // Set the NDK instance in the store
        // This will automatically register event listeners, including signer:ready
        setNDK(ndkInstance);
        
        // The currentUser will be set automatically when signer:ready is triggered
      } catch (error) {
        console.error('Failed to initialize NDK:', error);
        setStatus('Error: ' + (error instanceof Error ? error.message : String(error)));
      }
    };
    
    initializeNDK();
    
    // Clean up function (if needed)
    return () => {
      setStatus('Cleaned up');
    };
  }, [setNDK]);
  
  // Function to manually set the current user
  const handleLogin = async () => {
    if (!ndk) {
      setStatus('NDK not initialized');
      return;
    }
    
    try {
      // Ensure signer is ready
      if (ndk.signer) {
        await ndk.signer.blockUntilReady();
      }
      
      // Get the user
      const user = ndk.getUser();
      setCurrentUser(user);
      setStatus('Logged in');
    } catch (error) {
      console.error('Login failed:', error);
      setStatus('Login failed: ' + (error instanceof Error ? error.message : String(error)));
    }
  };
  
  // Function to log out
  const handleLogout = () => {
    setCurrentUser(null);
    setStatus('Logged out');
  };
  
  return (
    <div className="ndk-demo">
      <h1>NDK Demo</h1>
      
      <div className="status">
        <h2>Status: {status}</h2>
        <p>NDK Initialized: {ndk ? 'Yes' : 'No'}</p>
        <p>Current User: {currentUser ? `${currentUser.pubkey.slice(0, 8)}...` : 'None'}</p>
      </div>
      
      <div className="actions">
        <button 
          onClick={handleLogin} 
          disabled={!ndk || !!currentUser}
        >
          Login with Extension
        </button>
        
        <button 
          onClick={handleLogout} 
          disabled={!currentUser}
        >
          Logout
        </button>
      </div>
      
      {currentUser && (
        <div className="user-info">
          <h2>User Information</h2>
          <p><strong>Public Key:</strong> {currentUser.pubkey}</p>
          
          <button 
            onClick={async () => {
              if (!ndk || !currentUser) return;
              
              try {
                // Example: Post a simple note
                const event = await currentUser.publish({
                  kind: 1,
                  content: 'Hello from NDK Demo!',
                });
                
                setStatus(`Published event: ${event.id}`);
              } catch (error) {
                console.error('Failed to publish:', error);
                setStatus('Publish failed: ' + (error instanceof Error ? error.message : String(error)));
              }
            }}
          >
            Publish Test Note
          </button>
        </div>
      )}
    </div>
  );
}

export default NDKDemo;
```

## Using NDK in a Provider Pattern

A common pattern is to initialize the NDK instance at the application root and provide it to all components:

```tsx
import React, { useEffect } from 'react';
import NDK from '@nostr-dev-kit/ndk';
import { useNDK } from '@nostr-dev-kit/ndk-hooks';

// NDK Provider component
function NDKProvider({ children }) {
  const { setNDK } = useNDK();
  
  useEffect(() => {
    const setupNDK = async () => {
      const ndk = new NDK({
        explicitRelayUrls: [
          'wss://relay.nostr.band',
          'wss://relay.damus.io',
          'wss://nos.lol',
        ],
      });
      
      await ndk.connect();
      setNDK(ndk);
    };
    
    setupNDK();
  }, [setNDK]);
  
  return <>{children}</>;
}

// Root App component
function App() {
  return (
    <NDKProvider>
      <div className="app">
        {/* Your app components */}
        <Header />
        <MainContent />
        <Footer />
      </div>
    </NDKProvider>
  );
}

// Component that uses NDK
function MainContent() {
  const { ndk } = useNDK();
  const { currentUser } = useNDKCurrentUser();
  
  if (!ndk) {
    return <div>Loading NDK...</div>;
  }
  
  return (
    <div>
      <h1>Main Content</h1>
      {currentUser ? (
        <p>Logged in as: {currentUser.pubkey.slice(0, 8)}...</p>
      ) : (
        <p>Not logged in</p>
      )}
      {/* Rest of your application */}
    </div>
  );
}
```

## Working with NDK Events

This example shows how to work with NDK events:

```tsx
import React, { useEffect, useState } from 'react';
import { useNDK, useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks';
import { NDKEvent, NDKKind, NDKSubscription } from '@nostr-dev-kit/ndk';

function EventListener() {
  const { ndk } = useNDK();
  const [notes, setNotes] = useState<NDKEvent[]>([]);
  const [subscription, setSubscription] = useState<NDKSubscription | null>(null);
  
  // Set up a subscription when NDK is ready
  useEffect(() => {
    if (!ndk) return;
    
    // Create a subscription for text notes (kind 1)
    const sub = ndk.subscribe({
      kinds: [NDKKind.Text],
      limit: 10,
    });
    
    // Store events as they come in
    const events: NDKEvent[] = [];
    
    sub.on('event', (event: NDKEvent) => {
      events.push(event);
      setNotes([...events]); // Update state with a new array
    });
    
    // Store the subscription for cleanup
    setSubscription(sub);
    
    // Clean up the subscription when the component unmounts
    return () => {
      sub.stop();
    };
  }, [ndk]);
  
  return (
    <div>
      <h2>Recent Notes</h2>
      {notes.length === 0 ? (
        <p>Waiting for notes...</p>
      ) : (
        <ul>
          {notes.map((note) => (
            <li key={note.id}>
              <p><strong>{note.author.pubkey.slice(0, 8)}...</strong>: {note.content}</p>
              <small>
                {new Date(note.created_at! * 1000).toLocaleString()}
              </small>
            </li>
          ))}
        </ul>
      )}
      
      <button 
        onClick={() => subscription?.stop()}
        disabled={!subscription}
      >
        Stop Subscription
      </button>
    </div>
  );
}
```

These examples demonstrate the fundamental patterns for using the NDK store and hooks in your React applications. You can adapt and extend these examples to build more complex Nostr-enabled applications.
</file>

<file path="docs/ndk-hooks.md">
# NDK Store and Hooks

This document provides comprehensive documentation for the NDK store and hooks implementation in `@nostr-dev-kit/ndk-hooks`.

## Table of Contents

- [Overview](#overview)
- [Installation and Setup](#installation-and-setup)
- [Core Concepts](#core-concepts)
  - [NDK Store](#ndk-store)
  - [Current User](#current-user)
- [Usage](#usage)
  - [Setting up NDK in Your Application](#setting-up-ndk-in-your-application)
  - [Using the `useNDK` Hook](#using-the-usendk-hook)
  - [Using the `useNDKCurrentUser` Hook](#using-the-usendkcurrentuser-hook)
  - [Handling the `signer:ready` Event](#handling-the-signerready-event)
- [API Reference](#api-reference)
  - [`useNDK`](#usendk)
  - [`useNDKCurrentUser`](#usendkcurrentuser)
  - [`useNDKStore`](#usendkstore)
- [Best Practices](#best-practices)
- [Edge Cases and Troubleshooting](#edge-cases-and-troubleshooting)
- [Examples](#examples)

## Overview

The NDK store and hooks provide a simple and efficient way to manage your NDK instance and the current user across your React application. Built with Zustand, these utilities enable you to:

- Set up an NDK instance once and access it from anywhere in your component tree
- Access and update the current user from any component
- Handle NDK events like `signer:ready` with automatic user updates
- Build React applications with a clean, idiomatic approach to Nostr integration

## Installation and Setup

First, install the package:

```bash
# npm
npm install @nostr-dev-kit/ndk-hooks

# pnpm
pnpm add @nostr-dev-kit/ndk-hooks

# yarn
yarn add @nostr-dev-kit/ndk-hooks
```

### Requirements

- React 16.8.0 or higher (for hooks support)
- @nostr-dev-kit/ndk ^2.13
- zustand ^5

## Core Concepts

### NDK Store

The NDK store is a Zustand store that manages:

1. An NDK instance
2. The current user (if logged in)
3. Event listeners for NDK events

The store is automatically initialized when you import the hooks, but you need to set the NDK instance using the `setNDK` function.

### Current User

The current user represents the user that is currently logged in to your application. It is automatically set when:

1. The `signer:ready` event is fired by the NDK instance
2. You manually set it using the `setCurrentUser` function

## Usage

### Setting up NDK in Your Application

Typically, you'll want to set up the NDK instance at the root of your application:

```tsx
import React, { useEffect } from 'react';
import NDK from '@nostr-dev-kit/ndk';
import { useNDK } from '@nostr-dev-kit/ndk-hooks';

function App() {
  const { setNDK } = useNDK();
  
  useEffect(() => {
    // Initialize NDK
    const ndk = new NDK({
      explicitRelayUrls: ['wss://relay.nostr.band', 'wss://relay.damus.io'],
    });
    
    // Connect to relays
    ndk.connect().then(() => {
      // Set the NDK instance in the store
      setNDK(ndk);
    });
    
    return () => {
      // Clean up (optional)
    };
  }, [setNDK]);
  
  return (
    <div>
      {/* Your application content */}
      <YourComponents />
    </div>
  );
}
```

### Using the `useNDK` Hook

The `useNDK` hook provides access to the NDK instance and a function to set it:

```tsx
import { useNDK } from '@nostr-dev-kit/ndk-hooks';

function YourComponent() {
  const { ndk, setNDK } = useNDK();
  
  // Check if NDK is ready
  if (!ndk) {
    return <div>Loading NDK...</div>;
  }
  
  // Use the NDK instance
  const handleClick = async () => {
    const events = await ndk.fetchEvents({
      kinds: [1],
      limit: 10,
    });
    console.log('Latest notes:', events);
  };
  
  return (
    <div>
      <h2>NDK is ready!</h2>
      <button onClick={handleClick}>Fetch latest notes</button>
    </div>
  );
}
```

### Using the `useNDKCurrentUser` Hook

The `useNDKCurrentUser` hook provides access to the current user and a function to set it:

```tsx
import { useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks';

function Profile() {
  const { currentUser, setCurrentUser } = useNDKCurrentUser();
  
  // Check if user is logged in
  if (!currentUser) {
    return <div>Not logged in</div>;
  }
  
  // Log out handler
  const handleLogout = () => {
    setCurrentUser(null);
  };
  
  return (
    <div>
      <h2>User Profile</h2>
      <p>Public Key: {currentUser.pubkey}</p>
      <button onClick={handleLogout}>Log out</button>
    </div>
  );
}
```

### Handling the `signer:ready` Event

The NDK store automatically sets up an event listener for the `signer:ready` event. When this event is fired, the current user is automatically updated in the store.

This is particularly useful when using browser extensions like nos2x or Alby, which may not be immediately ready when your application loads.

Here's how it works behind the scenes:

```tsx
// This happens automatically when you call setNDK()
ndk.on('signer:ready', () => {
  const currentUser = ndk.getUser();
  // Updates the currentUser in the store
  setCurrentUser(currentUser);
});
```

## API Reference

### `useNDK`

```typescript
function useNDK(): {
  ndk: NDK | null;
  setNDK: (ndk: NDK) => void;
}
```

A hook that provides access to the NDK instance and a function to set it.

**Returns:**

- `ndk` - The current NDK instance or `null` if not set
- `setNDK` - Function to set the NDK instance

### `useNDKCurrentUser`

```typescript
function useNDKCurrentUser(): {
  currentUser: NDKUser | null;
  setCurrentUser: (user: NDKUser | null) => void;
}
```

A hook that provides access to the current user and a function to set it.

**Returns:**

- `currentUser` - The current user or `null` if not logged in
- `setCurrentUser` - Function to set the current user

### `useNDKStore`

```typescript
const useNDKStore = create<NDKStoreState>((set) => ({
  ndk: null,
  currentUser: null,
  setNDK: (ndk: NDK) => { /* ... */ },
  setCurrentUser: (user: NDKUser | null) => { /* ... */ },
}));
```

The underlying Zustand store that powers the hooks. You can use this directly for more advanced use cases.

**State:**

- `ndk` - The current NDK instance or `null` if not set
- `currentUser` - The current user or `null` if not logged in

**Methods:**

- `setNDK` - Function to set the NDK instance
- `setCurrentUser` - Function to set the current user

## Best Practices

### Initializing NDK Once

Initialize the NDK instance at the root of your application to ensure it's available throughout:

```tsx
// In your App.tsx or index.tsx
useEffect(() => {
  const ndk = new NDK({
    explicitRelayUrls: ['wss://relay.nostr.band', 'wss://relay.damus.io'],
  });
  
  ndk.connect().then(() => {
    setNDK(ndk);
  });
}, []);
```

### Managing User Authentication

When implementing user authentication, update the current user accordingly:

```tsx
// When signing in
const handleSignIn = async () => {
  // Using a BrowserExtensionSigner
  await ndk.signer.blockUntilReady();
  const user = ndk.getUser();
  // This will trigger updates in all components using useNDKCurrentUser
  setCurrentUser(user);
};

// When logging out
const handleLogout = () => {
  setCurrentUser(null);
};
```

### Error Handling

Always handle potential errors when working with NDK:

```tsx
try {
  await ndk.connect();
  setNDK(ndk);
} catch (error) {
  console.error('Failed to connect to relays:', error);
  // Show error message to user
}
```

## Edge Cases and Troubleshooting

### NDK Instance Not Available

If components are rendering before the NDK instance is available:

```tsx
function YourComponent() {
  const { ndk } = useNDK();
  
  if (!ndk) {
    return <div>Loading NDK...</div>;
  }
  
  // Safe to use ndk here
  return <div>NDK is ready!</div>;
}
```

### Handling Signer Delays

Browser extension signers may take time to become ready:

```tsx
const { ndk } = useNDK();
const { currentUser } = useNDKCurrentUser();
const [isSignerReady, setSignerReady] = useState(false);

useEffect(() => {
  if (ndk && ndk.signer) {
    // Listen for the signer to become ready
    ndk.on('signer:ready', () => {
      setSignerReady(true);
    });
    
    // Check if already ready
    if (ndk.signer.isReady) {
      setSignerReady(true);
    }
  }
}, [ndk]);

// Now you can use isSignerReady in your UI
```

### Clean Up Event Listeners

The NDK store handles cleanup automatically, but if you add your own listeners:

```tsx
useEffect(() => {
  if (!ndk) return;
  
  const handler = () => {
    console.log('NDK is ready');
  };
  
  ndk.on('ready', handler);
  
  return () => {
    ndk.off('ready', handler);
  };
}, [ndk]);
```

## Examples

### Complete Application Example

```tsx
import React, { useEffect, useState } from 'react';
import NDK, { NDKNip07Signer } from '@nostr-dev-kit/ndk';
import { useNDK, useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks';

function App() {
  const { ndk, setNDK } = useNDK();
  const { currentUser, setCurrentUser } = useNDKCurrentUser();
  const [isLoading, setIsLoading] = useState(true);
  
  // Initialize NDK with browser extension signer
  useEffect(() => {
    const initNDK = async () => {
      try {
        // Create NDK instance with browser extension signer
        const signer = new NDKNip07Signer();
        const ndk = new NDK({
          explicitRelayUrls: [
            'wss://relay.nostr.band',
            'wss://relay.damus.io',
            'wss://nos.lol',
          ],
          signer,
        });
        
        // Connect to relays
        await ndk.connect();
        
        // Set the NDK instance
        setNDK(ndk);
        
        // The signer:ready event will trigger automatically
        // and update the currentUser via the store's event listener
        
        setIsLoading(false);
      } catch (error) {
        console.error('Failed to initialize NDK:', error);
        setIsLoading(false);
      }
    };
    
    initNDK();
  }, [setNDK]);
  
  // Sign in handler
  const handleSignIn = async () => {
    if (!ndk || !ndk.signer) return;
    
    try {
      // This will prompt the user to authorize the extension
      await ndk.signer.blockUntilReady();
      
      // Get the user
      const user = ndk.getUser();
      setCurrentUser(user);
    } catch (error) {
      console.error('Sign in failed:', error);
    }
  };
  
  // Sign out handler
  const handleSignOut = () => {
    setCurrentUser(null);
  };
  
  if (isLoading) {
    return <div>Loading...</div>;
  }
  
  return (
    <div className="app">
      <h1>Nostr Application</h1>
      
      {currentUser ? (
        <div>
          <h2>Welcome, {currentUser.pubkey.substring(0, 8)}...</h2>
          <button onClick={handleSignOut}>Sign Out</button>
          
          {/* Your app content for logged-in users */}
          <div className="content">
            {/* Components that need NDK or currentUser */}
          </div>
        </div>
      ) : (
        <div>
          <h2>Please sign in</h2>
          <button onClick={handleSignIn}>
            Sign in with Nostr Extension
          </button>
        </div>
      )}
    </div>
  );
}

export default App;
```

This example demonstrates a complete application that:

1. Initializes NDK with a browser extension signer
2. Sets up the NDK store
3. Handles user authentication
4. Shows different UI based on the login state
</file>

<file path="docs/subscribe.md">
bsc# Subscribe Hook

The `useSubscribe` hook provides a convenient way to subscribe to Nostr events with React components.

## Usage

```tsx
import { useSubscribe } from '@nostr-dev-kit/ndk-hooks';
import { type NDKEvent, type NDKFilter } from '@nostr-dev-kit/ndk';

function MyComponent() {
  // Define filters
  const filters: NDKFilter[] = [
    { kinds: [1], limit: 10 }
  ];
  
  // Subscribe to events
  const { events, eose, isSubscribed } = useSubscribe<NDKEvent>(filters);
  
  return (
    <div>
      <h2>Events: {events.length}</h2>
      <p>EOSE (End of Stored Events): {eose ? 'Yes' : 'No'}</p>
      <p>Subscription active: {isSubscribed ? 'Yes' : 'No'}</p>
      
      {events.map(event => (
        <div key={event.id}>
          <h3>Event ID: {event.id}</h3>
          <p>Content: {event.content}</p>
        </div>
      ))}
    </div>
  );
}
```

## Options

The `useSubscribe` hook accepts the following options:

```tsx
const { events, eose, isSubscribed, subscription } = useSubscribe<NDKEvent>(
  filters,
  {
    // Whether to wrap the event with the kind-specific class when possible
    wrap: true,
    
    // Whether to include deleted events
    includeDeleted: false,
    
    // Buffer time in ms, false to disable buffering
    bufferMs: 30,
    
    // Optional relay URLs to connect to
    relays: ['wss://relay.example.com']
  },
  [/* dependencies */]
);
```

### Parameters

- `filters`: An array of NDKFilter objects or `false` to avoid running the subscription
- `opts`: (Optional) Subscription options
- `dependencies`: (Optional) Dependencies to re-run the subscription when they change

### Return Value

- `events`: Array of received events
- `eose`: Boolean flag indicating End of Stored Events
- `isSubscribed`: Boolean flag indicating if the subscription is active
- `subscription`: The underlying NDKSubscription object

## Performance Optimization

The hook uses event buffering to optimize performance when receiving many events in a short time. You can configure this behavior with the `bufferMs` option:

- Set to a number of milliseconds (default: 30ms)
- Set to `false` to disable buffering and process events immediately

## Cache Support

The hook automatically leverages the NDK cache adapter if one is configured with the NDK instance:

1. It checks if there are cached events available
2. It processes cached events before waiting for live events from relays

This provides a good user experience by showing existing data immediately.
</file>

<file path="examples/ndk-demo.tsx">
import React, { useEffect } from 'react';
import { useNDK } from '../src/hooks/ndk';
import { useNDKCurrentUser } from '../src/hooks/current-user';
import NDK from '@nostr-dev-kit/ndk';
const NDKDemo = () => {
  const { ndk, setNDK } = useNDK();
  const { currentUser } = useNDKCurrentUser();
  useEffect(() => {
    if (!ndk) {
      const newNdk = new NDK({
        explicitRelayUrls: [
          'wss://relay.damus.io',
          'wss://relay.snort.social',
        ],
      });
      newNdk.on('signer:ready', () => {
        console.log('Signer is ready!');
      });
      setNDK(newNdk);
      newNdk.connect();
    }
  }, [ndk, setNDK]);
  if (!ndk) {
    return <div>Initializing NDK...</div>;
  }
  return (
    <div>
      <h1>NDK Demo</h1>
      <p>NDK is initialized.</p>
      {currentUser ? (
        <div>
          <h2>Current User</h2>
          <p>Pubkey: {currentUser.pubkey}</p>
        </div>
      ) : (
        <p>No current user.</p>
      )}
    </div>
  );
};
export default NDKDemo;
</file>

<file path="examples/profile-demo.tsx">
import React, { useEffect, useState } from 'react';
import NDK from '@nostr-dev-kit/ndk';
import { useProfile, useUserProfilesStore } from '../src';
// Example component that displays a user profile
function UserProfile({ pubkey }: { pubkey: string }) {
    const profile = useProfile(pubkey);
    if (!profile) {
        return <div>Loading profile...</div>;
    }
    return (
        <div className="user-profile">
            {profile.picture && (
                <img 
                    src={profile.picture} 
                    alt={profile.name || 'User'} 
                    className="profile-picture"
                />
            )}
            <h2>{profile.name || 'Anonymous'}</h2>
            {profile.nip05 && <p className="nip05">{profile.nip05}</p>}
            {profile.about && <p className="about">{profile.about}</p>}
        </div>
    );
}
// Main app component
export default function App() {
    const [isNdkReady, setNdkReady] = useState(false);
    const [pubkey, setPubkey] = useState('');
    // Initialize NDK and the profiles store on mount
    useEffect(() => {
        async function initializeNDK() {
            const ndk = new NDK({
                explicitRelayUrls: [
                    'wss://relay.nostr.band',
                    'wss://relay.damus.io',
                    'wss://nos.lol',
                ],
            });
            await ndk.connect();
            // Initialize the profiles store with the NDK instance
            useUserProfilesStore.getState().initialize(ndk);
            setNdkReady(true);
        }
        initializeNDK().catch(console.error);
    }, []);
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        // Form validation would go here
    };
    return (
        <div className="app">
            <h1>Nostr Profile Viewer</h1>
            {!isNdkReady && <p>Initializing NDK...</p>}
            {isNdkReady && (
                <>
                    <form onSubmit={handleSubmit}>
                        <input
                            type="text"
                            placeholder="Enter a Nostr pubkey"
                            value={pubkey}
                            onChange={(e) => setPubkey(e.target.value)}
                            className="pubkey-input"
                        />
                        <button type="submit">View Profile</button>
                    </form>
                    {pubkey && <UserProfile pubkey={pubkey} />}
                </>
            )}
        </div>
    );
}
</file>

<file path="examples/subscribe-example.tsx">
import React, { useState } from 'react';
import { useNDK, useSubscribe } from '@nostr-dev-kit/ndk-hooks';
import NDK, { NDKEvent, NDKFilter } from '@nostr-dev-kit/ndk';
/**
 * Example component demonstrating the use of the subscribe hook
 */
function SubscribeExample() {
  const { ndk, setNDK } = useNDK();
  const [initialized, setInitialized] = useState(false);
  // Initialize NDK when component mounts
  React.useEffect(() => {
    if (!initialized) {
      const newNDK = new NDK({
        explicitRelayUrls: ['wss://relay.damus.io', 'wss://relay.nostr.band'],
      });
      newNDK.connect().then(() => {
        setNDK(newNDK);
        setInitialized(true);
      });
    }
  }, [initialized, setNDK]);
  // Define our subscription filters
  const filters: NDKFilter[] = [
    {
      kinds: [1],  // Regular notes
      limit: 10    // Only 10 most recent notes
    }
  ];
  // Subscribe to events with the filters
  const { events, eose, isSubscribed } = useSubscribe<NDKEvent>(filters);
  if (!initialized) {
    return <div>Initializing NDK...</div>;
  }
  return (
    <div>
      <h1>Nostr Events</h1>
      <div>
        <h2>Subscription Status</h2>
        <p>Connected to NDK: {ndk ? 'Yes' : 'No'}</p>
        <p>Subscription active: {isSubscribed ? 'Yes' : 'No'}</p>
        <p>End of Stored Events: {eose ? 'Yes' : 'No'}</p>
        <p>Events received: {events.length}</p>
      </div>
      <div>
        <h2>Events</h2>
        {events.length === 0 ? (
          <p>No events received yet...</p>
        ) : (
          <ul>
            {events.map(event => (
              <li key={event.id}>
                <strong>{event.id.substring(0, 8)}...</strong>
                <p><small>From: {event.pubkey.substring(0, 8)}...</small></p>
                <p>{event.content}</p>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
export default SubscribeExample;
</file>

<file path="src/hooks/current-user.ts">
import { useMemo } from 'react';
import { useNDKStore, type NDKStoreState } from '../stores/ndk';
import type { NDKUser } from '@nostr-dev-kit/ndk';
/**
 * Interface for the useNDKCurrentUser hook return value
 */
interface UseNDKCurrentUserResult {
  /**
   * The current user (if logged in)
   */
  currentUser: NDKUser | null;
  /**
   * Function to set the current user
   */
  setCurrentUser: (user: NDKUser | null) => void;
}
/**
 * Hook to access the current user and setCurrentUser function
 * 
 * @returns {UseNDKCurrentUserResult} Object containing the current user and setCurrentUser function
 */
export const useNDKCurrentUser = (): UseNDKCurrentUserResult => {
  const currentUser = useNDKStore((state) => state.currentUser);
  const setCurrentUser = useNDKStore((state) => state.setCurrentUser);
  // Memoize the result to ensure reference stability between renders
  return useMemo(() => ({ currentUser, setCurrentUser }), [currentUser, setCurrentUser]);
};
</file>

<file path="src/hooks/ndk.ts">
import { useMemo } from 'react';
import { useNDKStore, type NDKStoreState } from '../stores/ndk';
import type NDK from '@nostr-dev-kit/ndk';
/**
 * Interface for the useNDK hook return value
 */
interface UseNDKResult {
  /**
   * The NDK instance
   */
  ndk: NDK | null;
  /**
   * Function to set the NDK instance
   */
  setNDK: (ndk: NDK) => void;
}
/**
 * Hook to access the NDK instance and setNDK function
 * 
 * @returns {UseNDKResult} Object containing the NDK instance and setNDK function
 */
export const useNDK = (): UseNDKResult => {
  const ndk = useNDKStore((state) => state.ndk);
  const setNDK = useNDKStore((state) => state.setNDK);
  // Memoize the result to ensure reference stability between renders
  return useMemo(() => ({ ndk, setNDK }), [ndk, setNDK]);
};
</file>

<file path="src/hooks/profile.ts">
import type { Hexpubkey, NDKUserProfile } from '@nostr-dev-kit/ndk';
import { useEffect } from 'react';
import { useShallow } from 'zustand/shallow';
import {
    type UserProfilesStore,
    useUserProfilesStore,
} from '../stores/profiles';
/**
 * Hook for getting a user profile.
 * @param pubkey - The pubkey of the user to fetch
 * @param forceRefresh - Whether to force a refresh of the profile
 * @returns The user profile or undefined if not available
 */
export function useProfile(pubkey: Hexpubkey | undefined, forceRefresh?: boolean): NDKUserProfile | undefined {
    const fetchProfile = useUserProfilesStore((state) => state.fetchProfile);
    const profileSelector = useShallow((state: UserProfilesStore) =>
        pubkey ? state.profiles.get(pubkey) : undefined
    );
    const profile = useUserProfilesStore(profileSelector);
    useEffect(() => {
        if (pubkey) fetchProfile(pubkey, forceRefresh);
    }, [pubkey, fetchProfile, forceRefresh]);
    return profile;
}
</file>

<file path="src/hooks/subscribe.ts">
import {
  type NDKEvent,
  type NDKFilter,
  NDKRelaySet,
  type NDKSubscription,
  type NDKSubscriptionOptions,
} from '@nostr-dev-kit/ndk';
import { useCallback, useEffect, useMemo, useRef } from 'react';
import { useStore } from 'zustand';
import { createSubscribeStore } from '../stores/subscribe';
import { useNDK } from './ndk';
/**
 * Extends NDKEvent with a 'from' method to wrap events with a kind-specific handler
 */
export type NDKEventWithFrom<T extends NDKEvent> = T & { from: (event: NDKEvent) => T };
export type NDKEventWithAsyncFrom<T extends NDKEvent> = T & {
  from: (event: NDKEvent) => Promise<T>;
};
export type UseSubscribeOptions = NDKSubscriptionOptions & {
  /**
   * Whether to wrap the event with the kind-specific class when possible
   */
  wrap?: boolean;
  /**
   * Whether to include deleted events
   */
  includeDeleted?: boolean;
  /**
   * Buffer time in ms, false to disable buffering
   */
  bufferMs?: number | false;
  /**
   * Optional relay URLs to connect to
   */
  relays?: string[];
};
/**
 * React hook for subscribing to Nostr events
 * @param filters - Filters to run or false to avoid running the subscription. Note that when setting the filters to false, changing the filters prop
 *                  to have a different value will run the subscription, but changing the filters won't.
 * @param opts - UseSubscribeOptions
 * @param dependencies - any[] - dependencies to re-run the subscription when they change
 * @returns {Object} Subscription state
 * @returns {T[]} events - Array of received events
 * @returns {boolean} eose - End of stored events flag
 * @returns {boolean} isSubscribed - Subscription status
 */
export const useSubscribe = <T extends NDKEvent>(
  filters: NDKFilter[] | false,
  opts: UseSubscribeOptions = {},
  dependencies: any[] = []
) => {
  // Use stable reference for filters to avoid unnecessary re-renders
  const filtersRef = useRef(filters);
  filtersRef.current = filters;
  // Create a stable deps array to avoid re-creating the store on each render
  const stableDeps = useMemo(() => [...dependencies, !!filters], [JSON.stringify(dependencies), !!filters]);
  const { ndk } = useNDK();
  const store = useMemo(() => createSubscribeStore<T>(opts?.bufferMs), []);
  const storeInstance = useStore(store);
  /**
   * Map of eventIds that have been received by this subscription.
   *
   * Key: event identifier (event.dTag or event.id)
   *
   * Value: timestamp of the event, used to choose the
   * most recent event on replaceable events
   */
  const eventIds = useRef<Map<string, number>>(new Map());
  const isSubscribing = useRef(false);
  const relaySet = useMemo(() => {
    if (ndk && opts.relays && opts.relays.length > 0) {
      return NDKRelaySet.fromRelayUrls(opts.relays, ndk);
    }
    return undefined;
  }, [ndk, opts.relays ? opts.relays.join(',') : '']);
  const handleEvent = useCallback(
    (event: NDKEvent) => {
      const id = event.tagId();
      if (
        opts?.includeDeleted !== true &&
        event.isParamReplaceable() &&
        event.hasTag("deleted")
      ) {
        // We mark the event but we don't add the actual event, since
        // it has been deleted
        eventIds.current.set(id, event.created_at!);
        return;
      }
      event.once("deleted", () => {
        storeInstance.removeEventId(id);
      });
      storeInstance.addEvent(event as T);
      eventIds.current.set(id, event.created_at!);
    },
    [storeInstance, opts?.includeDeleted]
  );
  const handleEose = useCallback(() => {
    storeInstance.setEose();
  }, [storeInstance]);
  const handleClosed = useCallback(() => {
    storeInstance.setSubscription(undefined);
  }, [storeInstance]);
  // Use a ref to track whether we need to perform cleanup
  const hasSubscription = useRef(false);
  useEffect(() => {
    // Don't subscribe if no valid filters or NDK
    if (!filtersRef.current || (Array.isArray(filtersRef.current) && filtersRef.current.length === 0) || !ndk) {
      return;
    }
    // Prevent concurrent subscriptions
    if (isSubscribing.current) return;
    isSubscribing.current = true;
    // Clean up any existing subscription
    if (storeInstance.subscriptionRef) {
      storeInstance.subscriptionRef.stop();
      storeInstance.setSubscription(undefined);
      storeInstance.reset();
    }
    // Create and set up new subscription
    const subscription = ndk.subscribe(filtersRef.current, opts, relaySet, false);
    subscription.on("event", handleEvent);
    subscription.on("eose", handleEose);
    subscription.on("closed", handleClosed);
    storeInstance.setSubscription(subscription);
    hasSubscription.current = true;
    // Start the subscription and handle any initial events
    const cachedEvents = subscription.start(false);
    if (cachedEvents && Array.isArray(cachedEvents) && cachedEvents.length > 0) {
      // Use addEvents for batch processing of cached events
      storeInstance.addEvents(cachedEvents as T[]);
      // Update eventIds for all cached events
      for (const event of cachedEvents) {
        const id = event.tagId();
        eventIds.current.set(id, event.created_at!);
        // Set up deletion listener for each event
        event.once("deleted", () => {
          storeInstance.removeEventId(id);
        });
      }
    }
    isSubscribing.current = false;
    return () => {
      if (hasSubscription.current && storeInstance.subscriptionRef) {
        storeInstance.subscriptionRef.stop();
        storeInstance.setSubscription(undefined);
      }
      eventIds.current.clear();
      storeInstance.reset();
      hasSubscription.current = false;
    };
  }, [ndk, ...stableDeps, relaySet, handleEvent, handleEose, handleClosed]);
  return {
    events: storeInstance.events,
    eose: storeInstance.eose,
    isSubscribed: storeInstance.isSubscribed,
    subscription: storeInstance.subscriptionRef,
  };
};
/**
 * Utility function to check if two sets have any intersection
 * @param set1 First set
 * @param set2 Second set
 * @returns boolean True if sets have any intersection
 */
export const setHasAnyIntersection = (set1: Set<string>, set2: Set<string>) => {
  for (const item of set1) {
    if (set2.has(item)) return true;
  }
  return false;
};
</file>

<file path="src/stores/profiles/fetch-profile.ts">
import type { UserProfilesStore } from ".";
import { inSeconds } from "../../utils/time";
export const fetchProfileImplementation = (
    set: (fn: (state: UserProfilesStore) => Partial<UserProfilesStore>) => void,
    get: () => UserProfilesStore,
    pubkey?: string,
    force?: boolean
) => {
    const { ndk, profiles } = get();
    if (!ndk || !pubkey) return;
    const currentProfile = profiles.get(pubkey);
    if (currentProfile && !force) return;
    const user = ndk.getUser({ pubkey: pubkey });
    user.fetchProfile().then((profile) => {
        set((state) => {
            const profiles = new Map(state.profiles);
            if (profile) profiles.set(pubkey, profile);
            const lastFetchedAt = new Map(state.lastFetchedAt);
            lastFetchedAt.set(pubkey, inSeconds(Date.now()));
            return { profiles, lastFetchedAt };
        });
    }).catch((err) => {
        set((state) => {
            const lastFetchedAt = new Map(state.lastFetchedAt);
            lastFetchedAt.set(pubkey, inSeconds(Date.now()));
            return { lastFetchedAt };
        });
    });
}
</file>

<file path="src/stores/profiles/index.ts">
import type NDK from "@nostr-dev-kit/ndk";
import type { Hexpubkey, NDKUserProfile } from "@nostr-dev-kit/ndk";
import { create } from "zustand";
import { fetchProfileImplementation } from "./fetch-profile";
import { initializeProfilesStore } from "./initialize";
import { setProfileImplementation } from "./set-profile";
interface UserProfilesItems {
    /**
     * The NDK instance
     */ 
    ndk: NDK | undefined;
    /**
     * The profile map
     */
    profiles: Map<Hexpubkey, NDKUserProfile>;
    /**
     * Map of timestamps in seconds of the last time a profile was fetched
     * (even if we couldn't find one)
     */
    lastFetchedAt: Map<Hexpubkey, number>;
};
interface UserProfilesStoreActions {
    // Initializes the store; this must be called the initialization of the app
    initialize: (ndk: NDK) => void;
    /**
     * Store an already fetched profile
     * @param pubkey - The pubkey of the profile to store
     * @param profile - The profile to store
     * @param cachedAt - The timestamp in seconds when the profile was retrieved
     */
    setProfile: (pubkey: string, profile: NDKUserProfile, cachedAt?: number) => void;
    /*
     * Fetch a profile from the NDK instance
     * 
     * @param pubkey - The pubkey of the profile to fetch
     * @param force - Whether to force the fetch even if the profile is already cached
     */
    fetchProfile: (pubkey?: string, force?: boolean) => void;
}
export type UserProfilesStore = UserProfilesItems & UserProfilesStoreActions;
export const useUserProfilesStore = create<UserProfilesStore>((set, get) => ({
    profiles: new Map(),
    lastFetchedAt: new Map(),
    ndk: undefined,
    initialize: initializeProfilesStore.bind(null, set),
    setProfile: setProfileImplementation.bind(null, set),
    fetchProfile: fetchProfileImplementation.bind(null, set, get),
}));
</file>

<file path="src/stores/profiles/iniitialize.ts">
import type { Hexpubkey, NDKUserProfile } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
import type { UserProfilesStore } from ".";
export function initializeProfilesStore(set: (state: Partial<UserProfilesStore>) => void, ndk: NDK) {
    // warm up from the cache if we have one
    const cacheAdapter = ndk.cacheAdapter;
    if (!cacheAdapter?.getAllProfilesSync) return;
    // get all the keys
    const keys = cacheAdapter.getAllProfilesSync();
    const profiles = new Map<Hexpubkey, NDKUserProfile>();
    const lastFetchedAt = new Map<Hexpubkey, number>();
    for (const [key, profile] of keys) {
        profiles.set(key, profile);
        lastFetchedAt.set(key, profile.cachedAt ?? 0);
    }
    set({ profiles, lastFetchedAt, ndk });
}
</file>

<file path="src/stores/profiles/initialize.ts">
import type { Hexpubkey, NDKUserProfile } from "@nostr-dev-kit/ndk";
import type NDK from "@nostr-dev-kit/ndk";
import type { UserProfilesStore } from ".";
export function initializeProfilesStore(set: (state: Partial<UserProfilesStore>) => void, ndk: NDK) {
    // warm up from the cache if we have one
    const cacheAdapter = ndk.cacheAdapter;
    if (!cacheAdapter?.getAllProfilesSync) return;
    // get all the keys
    const keys = cacheAdapter.getAllProfilesSync();
    const profiles = new Map<Hexpubkey, NDKUserProfile>();
    const lastFetchedAt = new Map<Hexpubkey, number>();
    for (const [key, profile] of keys) {
        profiles.set(key, profile);
        lastFetchedAt.set(key, profile.cachedAt ?? 0);
    }
    set({ profiles, lastFetchedAt, ndk });
}
</file>

<file path="src/stores/profiles/set-profile.ts">
import type { NDKUserProfile } from "@nostr-dev-kit/ndk";
import { inSeconds } from "../../utils/time";
import type { UserProfilesStore } from "./index";
export const setProfileImplementation = (
    set: (fn: (state: UserProfilesStore) => Partial<UserProfilesStore>) => void,
    pubkey: string,
    profile: NDKUserProfile,
    cachedAt?: number
) => {
    set((state) => {
        const newProfiles = new Map(state.profiles);
        newProfiles.set(pubkey, profile);
        const newLastFetchedAt = new Map(state.lastFetchedAt);
        newLastFetchedAt.set(pubkey, cachedAt ?? inSeconds(Date.now()));
        return { profiles: newProfiles, lastFetchedAt: newLastFetchedAt };
    });
};
</file>

<file path="src/stores/ndk.ts">
import { create } from 'zustand';
import NDK, { NDKUser } from '@nostr-dev-kit/ndk';
/**
 * Interface for the NDK store state
 */
export interface NDKStoreState {
  /**
   * The NDK instance
   */
  ndk: NDK | null;
  /**
   * The current user (if logged in)
   */
  currentUser: NDKUser | null;
  /**
   * Sets the NDK instance
   */
  setNDK: (ndk: NDK) => void;
  /**
   * Sets the current user
   */
  setCurrentUser: (user: NDKUser | null) => void;
}
/**
 * Zustand store for managing the NDK instance and current user
 */
export const useNDKStore = create<NDKStoreState>((set, get) => {
  // Keep track of the registered event handlers to clean them up later
  return {
    ndk: null,
    currentUser: null,
    setNDK: (ndk: NDK) => {
      // The signer:ready event means the current user is available
      // In a real implementation, we would use ndk.activeUser
      const signerReadyHandler = () => {
        const currentUser = ndk.activeUser || null;
        set({ currentUser });
      };
      set((state) => {
        const currentNDK = state.ndk;
        // Clean up event listeners from previous NDK instance
        if (currentNDK) {
          currentNDK.off('signer:ready', signerReadyHandler);
        }
        // Set up the signer:ready event listener
        ndk.on('signer:ready', signerReadyHandler);
        return { ndk };
      });
    },
    setCurrentUser: (user: NDKUser | null) => {
      set({ currentUser: user });
    },
  };
});
</file>

<file path="src/stores/subscribe.ts">
import { createStore } from 'zustand/vanilla';
import type { NDKEvent, NDKSubscription } from '@nostr-dev-kit/ndk';
/**
 * Store interface for managing subscription state
 * @interface SubscribeStore
 * @property {T[]} events - Array of received events
 * @property {Map<string, T>} eventMap - Map of events by ID
 * @property {boolean} eose - End of stored events flag
 * @property {boolean} isSubscribed - Subscription status
 */
export interface SubscribeStore<T extends NDKEvent> {
  events: T[];
  eventMap: Map<string, T>;
  eose: boolean;
  isSubscribed: boolean;
  addEvent: (event: T) => void;
  addEvents: (events: T[]) => void;
  removeEventId: (id: string) => void;
  setEose: () => void;
  reset: () => void;
  setSubscription: (sub: NDKSubscription | undefined) => void;
  subscriptionRef: NDKSubscription | undefined;
}
/**
 * Creates a store to manage subscription state with optional event buffering
 * @param bufferMs - Buffer time in milliseconds, false to disable buffering
 */
export const createSubscribeStore = <T extends NDKEvent>(bufferMs: number | false = 30) => {
  const store = createStore<SubscribeStore<T>>((set, get) => {
    // Global buffer outside of the store state
    const buffer = new Map<string, T>();
    let timeout: NodeJS.Timeout | null = null;
    // Function to flush buffer and update state
    const flushBuffer = () => {
      const state = get();
      const newEventMap = new Map(state.eventMap);
      let hasChanges = false;
      // Add buffered events to the event map
      for (const [id, event] of buffer.entries()) {
        const existingEvent = newEventMap.get(id);
        // Only add newer events or events without existing entry
        if (!existingEvent || (existingEvent.created_at !== undefined && 
            event.created_at !== undefined && 
            event.created_at > existingEvent.created_at)) {
          newEventMap.set(id, event);
          hasChanges = true;
        }
      }
      // Clear buffer after processing
      buffer.clear();
      // Only update state if there were changes
      if (hasChanges) {
        // Create a new events array from the map values
        const newEvents = Array.from(newEventMap.values());
        // Update state
        set({ eventMap: newEventMap, events: newEvents });
      }
      timeout = null;
    };
    return {
      events: [],
      eventMap: new Map<string, T>(),
      eose: false,
      isSubscribed: false,
      subscriptionRef: undefined,
      // Add an event to the store
      addEvent: (event) => {
        const id = event.tagId();
        if (bufferMs !== false) {
          // Buffering is enabled
          // Check if we already have a newer version of this event
          const existingInBuffer = buffer.get(id);
          const existingInStore = get().eventMap.get(id);
          if (existingInBuffer && existingInBuffer.created_at !== undefined && 
              event.created_at !== undefined && existingInBuffer.created_at >= event.created_at) {
            return; // Skip older events
          }
          if (existingInStore && existingInStore.created_at !== undefined && 
              event.created_at !== undefined && existingInStore.created_at >= event.created_at) {
            return; // Skip older events
          }
          // Add to buffer
          buffer.set(id, event);
          // Schedule buffer flush if not already scheduled
          if (!timeout) {
            timeout = setTimeout(flushBuffer, bufferMs);
          }
        } else {
          // Immediate update (no buffering)
          const state = get();
          const newEventMap = new Map(state.eventMap);
          const existingEvent = newEventMap.get(id);
          // Skip older events
          if (existingEvent && existingEvent.created_at !== undefined && 
              event.created_at !== undefined && existingEvent.created_at >= event.created_at) {
            return;
          }
          // Update map with new event
          newEventMap.set(id, event);
          // Create new events array
          const newEvents = Array.from(newEventMap.values());
          // Update state
          set({ eventMap: newEventMap, events: newEvents });
        }
      },
      // Add multiple events to the store efficiently
      addEvents: (events) => {
        if (!events || events.length === 0) return;
        if (bufferMs !== false) {
          // Buffering is enabled - add all valid events to buffer
          let needsFlush = false;
          for (const event of events) {
            if (!event) continue;
            const id = event.tagId();
            const existingInBuffer = buffer.get(id);
            const existingInStore = get().eventMap.get(id);
            // Skip older events
            if (existingInBuffer && existingInBuffer.created_at !== undefined && 
                event.created_at !== undefined && existingInBuffer.created_at >= event.created_at) {
              continue;
            }
            if (existingInStore && existingInStore.created_at !== undefined && 
                event.created_at !== undefined && existingInStore.created_at >= event.created_at) {
              continue;
            }
            // Add to buffer
            buffer.set(id, event);
            needsFlush = true;
          }
          // Schedule buffer flush if needed and not already scheduled
          if (needsFlush && !timeout) {
            timeout = setTimeout(flushBuffer, bufferMs);
          }
        } else {
          // Immediate update (no buffering)
          const state = get();
          const newEventMap = new Map(state.eventMap);
          // Process all events at once
          let hasUpdates = false;
          for (const event of events) {
            if (!event) continue;
            const id = event.tagId();
            const existingEvent = newEventMap.get(id);
            // Skip older events
            if (existingEvent && existingEvent.created_at !== undefined && 
                event.created_at !== undefined && existingEvent.created_at >= event.created_at) {
              continue;
            }
            // Update map with new event
            newEventMap.set(id, event);
            hasUpdates = true;
          }
          // Only update state if there were actual changes
          if (hasUpdates) {
            const newEvents = Array.from(newEventMap.values());
            set({ eventMap: newEventMap, events: newEvents });
          }
        }
      },
      // Remove an event by ID
      removeEventId: (id) => {
        const state = get();
        const newEventMap = new Map(state.eventMap);
        newEventMap.delete(id);
        const newEvents = Array.from(newEventMap.values());
        set({ eventMap: newEventMap, events: newEvents });
      },
      // Set EOSE flag and flush buffer
      setEose: () => {
        // Ensure buffer is flushed immediately
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
          flushBuffer();
        }
        // Update EOSE flag
        set({ eose: true });
        // Adjust buffer time for faster updates after EOSE
        if (bufferMs !== false) {
          bufferMs = 16;
        }
      },
      // Reset store to initial state
      reset: () => {
        // Clear buffer and any pending flush
        buffer.clear();
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        // Reset state
        set({
          events: [],
          eventMap: new Map<string, T>(),
          eose: false,
          isSubscribed: false,
          subscriptionRef: undefined
        });
      },
      // Set subscription reference
      setSubscription: (sub) => {
        set({ subscriptionRef: sub, isSubscribed: !!sub });
      }
    };
  });
  return store;
};
</file>

<file path="src/utils/time.ts">
export const inSeconds = (ms: number) => ms / 1000;
</file>

<file path="src/index.ts">
/**
 * @nostr-dev-kit/ndk-hooks
 * 
 * React hooks for the NDK (Nostr Development Kit)
 */
// Export hooks
export * from './hooks/profile';
export * from './hooks/ndk';
export * from './hooks/current-user';
export * from './hooks/subscribe';
// Export stores
export * from './stores/profiles';
export * from './stores/ndk';
export * from './stores/subscribe';
</file>

<file path="test/hooks/current-user.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook } from '@testing-library/react-hooks';
import { useNDKCurrentUser } from '../../src/hooks/current-user';
import { useNDKStore } from '../../src/stores/ndk';
import type { NDKUser } from '@nostr-dev-kit/ndk';
// Create mocks
const mockSetCurrentUser = vi.fn();
let mockCurrentUser: NDKUser | null = null;
// Mock dependencies
vi.mock('../../src/stores/ndk', () => {
  return {
    useNDKStore: vi.fn((selector) => {
      if (typeof selector === 'function') {
        return selector({
          currentUser: mockCurrentUser,
          setCurrentUser: mockSetCurrentUser,
        });
      }
      // When called directly with no selector, return the store
      if (selector === undefined) {
        return { currentUser: mockCurrentUser, setCurrentUser: mockSetCurrentUser };
      }
      return { currentUser: mockCurrentUser, setCurrentUser: mockSetCurrentUser };
    }),
  };
});
describe('useNDKCurrentUser', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset the mocks
    mockCurrentUser = null;
    mockSetCurrentUser.mockReset();
    // Update the store mock implementation
    (useNDKStore as any).mockImplementation((selector) => {
      if (typeof selector === 'function') {
        return selector({
          currentUser: mockCurrentUser,
          setCurrentUser: mockSetCurrentUser,
        });
      }
      // When called directly with no selector, return the store
      if (selector === undefined) {
        return { currentUser: mockCurrentUser, setCurrentUser: mockSetCurrentUser };
      }
      return { currentUser: mockCurrentUser, setCurrentUser: mockSetCurrentUser };
    });
  });
  it('should return currentUser and setCurrentUser from the store', () => {
    const { result } = renderHook(() => useNDKCurrentUser());
    expect(result.current).toEqual({
      currentUser: null,
      setCurrentUser: mockSetCurrentUser,
    });
  });
  it('should return updated currentUser when store changes', () => {
    // Initial render with null currentUser
    const { result, rerender } = renderHook(() => useNDKCurrentUser());
    expect(result.current.currentUser).toBeNull();
    // Update the mock currentUser and rerender
    const newMockUser = { pubkey: 'test-pubkey' } as NDKUser;
    mockCurrentUser = newMockUser;
    rerender();
    expect(result.current.currentUser).toBe(newMockUser);
  });
  it('should maintain reference stability between rerenders', () => {
    const { result, rerender } = renderHook(() => useNDKCurrentUser());
    const firstRenderResult = result.current;
    rerender();
    expect(result.current).toBe(firstRenderResult);
  });
});
</file>

<file path="test/hooks/ndk.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook } from '@testing-library/react-hooks';
import { useNDK } from '../../src/hooks/ndk';
import { useNDKStore } from '../../src/stores/ndk';
import NDK from '@nostr-dev-kit/ndk';
// Create mocks
const mockSetNDK = vi.fn();
let mockNDK: NDK | null = null;
// Mock dependencies
vi.mock('../../src/stores/ndk', () => {
  return {
    useNDKStore: vi.fn((selector) => {
      if (typeof selector === 'function') {
        return selector({
          ndk: mockNDK,
          setNDK: mockSetNDK,
        });
      }
      // When called directly with no selector, return the store
      if (selector === undefined) {
        return { ndk: mockNDK, setNDK: mockSetNDK };
      }
      return { ndk: mockNDK, setNDK: mockSetNDK };
    }),
  };
});
describe('useNDK', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset the mocks
    mockNDK = null;
    mockSetNDK.mockReset();
    // Update the store mock implementation
    (useNDKStore as any).mockImplementation((selector) => {
      if (typeof selector === 'function') {
        return selector({
          ndk: mockNDK,
          setNDK: mockSetNDK,
        });
      }
      // When called directly with no selector, return the store
      if (selector === undefined) {
        return { ndk: mockNDK, setNDK: mockSetNDK };
      }
      return { ndk: mockNDK, setNDK: mockSetNDK };
    });
  });
  it('should return ndk and setNDK from the store', () => {
    const { result } = renderHook(() => useNDK());
    expect(result.current).toEqual({
      ndk: null,
      setNDK: mockSetNDK,
    });
  });
  it('should return updated ndk when store changes', () => {
    // Initial render with null ndk
    const { result, rerender } = renderHook(() => useNDK());
    expect(result.current.ndk).toBeNull();
    // Update the mock NDK and rerender
    const newMockNDK = new NDK({ explicitRelayUrls: [] });
    mockNDK = newMockNDK;
    rerender();
    expect(result.current.ndk).toBe(newMockNDK);
  });
  it('should maintain reference stability between rerenders', () => {
    const { result, rerender } = renderHook(() => useNDK());
    const firstRenderResult = result.current;
    rerender();
    expect(result.current).toBe(firstRenderResult);
  });
});
</file>

<file path="test/hooks/profile.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react-hooks';
import { useProfile } from '../../src/hooks/profile';
import { useUserProfilesStore } from '../../src/stores/profiles';
// Create mocks
const mockFetchProfile = vi.fn();
const mockProfiles = new Map();
// Mock dependencies
vi.mock('../../src/stores/profiles', () => {
    return {
        useUserProfilesStore: vi.fn((selector) => {
            if (typeof selector === 'function') {
                return selector({
                    profiles: mockProfiles,
                    fetchProfile: mockFetchProfile,
                });
            }
            // When called directly with no selector, return the fetchProfile function
            if (selector === undefined) {
                return { fetchProfile: mockFetchProfile };
            }
            return mockFetchProfile;
        }),
    };
});
describe('useProfile', () => {
    const testPubkey = '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f';
    const mockProfile = { name: 'Test User', picture: 'https://example.com/pic.jpg' };
    beforeEach(() => {
        vi.clearAllMocks();
        // Reset the mocks
        mockProfiles.clear();
        mockFetchProfile.mockReset();
        // Update the store mock implementation
        (useUserProfilesStore as any).mockImplementation((selector) => {
            if (typeof selector === 'function') {
                return selector({
                    profiles: mockProfiles,
                    fetchProfile: mockFetchProfile,
                });
            }
            // When called directly with no selector, return the store
            if (selector === undefined) {
                return { fetchProfile: mockFetchProfile };
            }
            return mockFetchProfile;
        });
    });
    it('should return undefined if no pubkey is provided', () => {
        const { result } = renderHook(() => useProfile(undefined));
        expect(result.current).toBeUndefined();
    });
    it('should call fetchProfile with the provided pubkey', () => {
        renderHook(() => useProfile(testPubkey));
        expect(mockFetchProfile).toHaveBeenCalledWith(testPubkey, undefined);
    });
    it('should call fetchProfile with forceRefresh when provided', () => {
        renderHook(() => useProfile(testPubkey, true));
        expect(mockFetchProfile).toHaveBeenCalledWith(testPubkey, true);
    });
    it('should return profile when available in the store', () => {
        // Add the profile to the mock profiles map
        mockProfiles.set(testPubkey, mockProfile);
        const { result } = renderHook(() => useProfile(testPubkey));
        expect(result.current).toEqual(mockProfile);
    });
});
</file>

<file path="test/stores/ndk.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import NDK from '@nostr-dev-kit/ndk';
import { act } from '@testing-library/react-hooks';
import { useNDKStore } from '../../src/stores/ndk';
describe('NDK Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useNDKStore.setState({
      ndk: null,
      currentUser: null,
      setNDK: useNDKStore.getState().setNDK,
      setCurrentUser: useNDKStore.getState().setCurrentUser,
    });
    vi.clearAllMocks();
  });
  it('should initialize with null values', () => {
    const { ndk, currentUser } = useNDKStore.getState();
    expect(ndk).toBeNull();
    expect(currentUser).toBeNull();
  });
  it('should set NDK instance via setNDK', () => {
    const { setNDK } = useNDKStore.getState();
    const mockNDK = new NDK({ explicitRelayUrls: [] });
    act(() => {
      setNDK(mockNDK);
    });
    const { ndk } = useNDKStore.getState();
    expect(ndk).toBe(mockNDK);
  });
  it('should set up event listener for signer:ready', () => {
    const { setNDK } = useNDKStore.getState();
    const mockNDK = new NDK({ explicitRelayUrls: [] });
    mockNDK.on = vi.fn();
    act(() => {
      setNDK(mockNDK);
    });
    expect(mockNDK.on).toHaveBeenCalledWith('signer:ready', expect.any(Function));
  });
  it('should update currentUser when signer is ready', () => {
    const { setNDK } = useNDKStore.getState();
    const mockNDK = new NDK({ explicitRelayUrls: [] });
    const mockUser = { pubkey: 'test-pubkey', ndk: mockNDK };
    // Mock the on method to capture the callback
    let signerReadyCallback;
    mockNDK.on = vi.fn((event: string, callback: any) => {
      if (event === 'signer:ready') {
        signerReadyCallback = callback;
      }
    }) as any;
    // Mock activeUser to return our test user
    mockNDK.activeUser = mockUser as any;
    act(() => {
      setNDK(mockNDK);
    });
    // Trigger the signer:ready event
    act(() => {
      signerReadyCallback();
    });
    const { currentUser } = useNDKStore.getState();
    expect(currentUser).toBe(mockUser);
    // expect(mockNDK.getUser).toHaveBeenCalledTimes(1);
  });
  it('should manually set currentUser', () => {
    const { setCurrentUser } = useNDKStore.getState();
    const mockUser = { pubkey: 'test-pubkey' };
    act(() => {
      setCurrentUser(mockUser as any);
    });
    const { currentUser } = useNDKStore.getState();
    expect(currentUser).toBe(mockUser);
  });
  it('should clean up event listeners when setting a new NDK instance', () => {
    const { setNDK } = useNDKStore.getState();
    const mockNDK1 = new NDK({ explicitRelayUrls: [] });
    const mockNDK2 = new NDK({ explicitRelayUrls: [] });
    mockNDK1.on = vi.fn();
    mockNDK1.off = vi.fn();
    mockNDK2.on = vi.fn();
    // Set the first NDK instance
    act(() => {
      setNDK(mockNDK1);
    });
    // Now set a second NDK instance
    act(() => {
      setNDK(mockNDK2);
    });
    // Verify cleanup was done on the first instance
    expect(mockNDK1.off).toHaveBeenCalledWith('signer:ready', expect.any(Function));
    // And the new instance has listeners set up
    expect(mockNDK2.on).toHaveBeenCalledWith('signer:ready', expect.any(Function));
  });
});
</file>

<file path="test/stores/profiles.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useUserProfilesStore } from '../../src/stores/profiles';
import { act } from '@testing-library/react-hooks';
// Mock NDK dependencies
const mockFetchProfile = vi.fn();
const mockUser = {
    fetchProfile: vi.fn(() => Promise.resolve({ name: 'Test User' })),
};
const mockNDK = {
    cacheAdapter: {
        getAllProfilesSync: vi.fn(() => {
            const profiles = new Map();
            profiles.set('cachedPubkey', { 
                name: 'Cached User',
                cachedAt: 1000,
            });
            return profiles;
        }),
    },
    getUser: vi.fn(() => mockUser),
};
describe('Profiles Store', () => {
    const testPubkey = '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f';
    const testProfile = { name: 'Test User', picture: 'https://example.com/pic.jpg' };
    beforeEach(() => {
        // Reset store by getting the current state and setting it back with empty collections
        useUserProfilesStore.setState({
            ndk: undefined,
            profiles: new Map(),
            lastFetchedAt: new Map(),
            initialize: useUserProfilesStore.getState().initialize,
            setProfile: useUserProfilesStore.getState().setProfile,
            fetchProfile: useUserProfilesStore.getState().fetchProfile,
        });
        vi.clearAllMocks();
    });
    describe('initialize', () => {
        it('should initialize the store with cached profiles', () => {
            const store = useUserProfilesStore.getState();
            act(() => {
                store.initialize(mockNDK as any);
            });
            const state = useUserProfilesStore.getState();
            expect(state.ndk).toBe(mockNDK);
            expect(state.profiles.size).toBe(1);
            expect(state.profiles.get('cachedPubkey')).toEqual({ name: 'Cached User', cachedAt: 1000 });
            expect(state.lastFetchedAt.get('cachedPubkey')).toBe(1000);
        });
        it('should not populate state if no cache adapter is available', () => {
            const store = useUserProfilesStore.getState();
            const mockEmptyNDK = { cacheAdapter: null };
            act(() => {
                store.initialize(mockEmptyNDK as any);
            });
            const state = useUserProfilesStore.getState();
            expect(state.profiles.size).toBe(0);
        });
    });
    describe('setProfile', () => {
        it('should add a profile to the store', () => {
            const store = useUserProfilesStore.getState();
            act(() => {
                store.setProfile(testPubkey, testProfile);
            });
            const state = useUserProfilesStore.getState();
            expect(state.profiles.get(testPubkey)).toEqual(testProfile);
            expect(state.lastFetchedAt.has(testPubkey)).toBe(true);
        });
        it('should use provided cachedAt timestamp', () => {
            const store = useUserProfilesStore.getState();
            const timestamp = 12345;
            act(() => {
                store.setProfile(testPubkey, testProfile, timestamp);
            });
            const state = useUserProfilesStore.getState();
            expect(state.lastFetchedAt.get(testPubkey)).toBe(timestamp);
        });
    });
    describe('fetchProfile', () => {
        it('should not fetch if pubkey is undefined', async () => {
            const store = useUserProfilesStore.getState();
            act(() => {
                store.fetchProfile(undefined);
            });
            expect(mockNDK.getUser).not.toHaveBeenCalled();
        });
        it('should not fetch if NDK is not initialized', async () => {
            const store = useUserProfilesStore.getState();
            act(() => {
                store.fetchProfile(testPubkey);
            });
            expect(mockNDK.getUser).not.toHaveBeenCalled();
        });
        it('should fetch and store profile when NDK is initialized', async () => {
            const store = useUserProfilesStore.getState();
            act(() => {
                store.initialize(mockNDK as any);
            });
            await act(async () => {
                store.fetchProfile(testPubkey);
            });
            expect(mockNDK.getUser).toHaveBeenCalledWith({ pubkey: testPubkey });
            expect(mockUser.fetchProfile).toHaveBeenCalled();
            // Wait for async operation to complete
            await vi.waitFor(() => {
                const state = useUserProfilesStore.getState();
                expect(state.profiles.has(testPubkey)).toBe(true);
            });
        });
        it('should update lastFetchedAt even if profile fetch fails', async () => {
            const store = useUserProfilesStore.getState();
            // Make the fetch fail
            mockUser.fetchProfile.mockRejectedValueOnce(new Error('Fetch failed'));
            act(() => {
                store.initialize(mockNDK as any);
            });
            await act(async () => {
                store.fetchProfile(testPubkey);
            });
            expect(mockNDK.getUser).toHaveBeenCalledWith({ pubkey: testPubkey });
            // Wait for async operation to complete
            await vi.waitFor(() => {
                const state = useUserProfilesStore.getState();
                expect(state.lastFetchedAt.has(testPubkey)).toBe(true);
                expect(state.profiles.has(testPubkey)).toBe(false);
            });
        });
    });
});
</file>

<file path="test/setup.ts">
import { vi } from 'vitest';
// Mock react's useEffect and useState
vi.mock('react', async () => {
    const actual = await vi.importActual('react');
    return {
        ...actual as object,
        useEffect: vi.fn((fn) => fn()),
    };
});
// Silence console errors during tests
vi.spyOn(console, 'error').mockImplementation(() => {});
</file>

<file path="test/subscribe.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act } from '@testing-library/react-hooks';
import { createSubscribeStore, type SubscribeStore } from '../src/stores/subscribe';
import { useSubscribe } from '../src/hooks/subscribe';
import { useNDK } from '../src/hooks/ndk';
import NDK, { 
  NDKEvent, 
  NDKSubscription, 
  NDKFilter,
  NDKRelaySet 
} from '@nostr-dev-kit/ndk';
// Create a proper Mock for NDKEvent
class MockEvent {
  id: string;
  pubkey: string;
  created_at: number;
  content: string;
  kind: number;
  tags: string[][];
  sig: string;
  _author: any;
  relay: any;
  onRelays: any[];
  rawEvent: any;
  constructor(data: Partial<MockEvent> = {}) {
    this.id = data.id || `id-${Math.random().toString(36).substring(7)}`;
    this.pubkey = data.pubkey || 'test-pubkey';
    this.created_at = data.created_at || Math.floor(Date.now() / 1000);
    this.content = data.content || 'test content';
    this.kind = data.kind || 1;
    this.tags = data.tags || [];
    this.sig = data.sig || 'test-sig';
    this._author = null;
    this.relay = null;
    this.onRelays = [];
    this.rawEvent = { id: this.id, pubkey: this.pubkey, created_at: this.created_at, content: this.content, kind: this.kind, tags: this.tags, sig: this.sig };
  }
  tagId() {
    return this.id;
  }
  isParamReplaceable() {
    return false;
  }
  hasTag(tagName: string) {
    return this.tags.some(tag => tag[0] === tagName);
  }
  once(event: string, callback: () => void) {
    // Mock implementation
  }
}
// Setup the mocks
vi.mock('@nostr-dev-kit/ndk', () => {
  return {
    default: vi.fn(),
    NDKRelaySet: {
      fromRelayUrls: vi.fn(() => ({
        relays: [],
        add: vi.fn()
      }))
    },
    NDKEvent: vi.fn().mockImplementation((data) => new MockEvent(data))
  };
});
vi.mock('../src/hooks/ndk', () => ({
  useNDK: vi.fn()
}));
// Helper to create mock subscription
const createMockSubscription = () => {
  const mockSub = {
    on: vi.fn(),
    off: vi.fn(),
    stop: vi.fn(),
    start: vi.fn(() => []),
    events: [] as NDKEvent[],
    eose: false
  };
  return mockSub as unknown as NDKSubscription;
};
describe('Subscribe Store', () => {
  let store: ReturnType<typeof createSubscribeStore<NDKEvent>>;
  beforeEach(() => {
    vi.useFakeTimers();
    store = createSubscribeStore<NDKEvent>();
  });
  afterEach(() => {
    vi.useRealTimers();
  });
  describe('event buffering', () => {
    it('should buffer events and not update state immediately with default buffer time', () => {
      const event = new MockEvent() as unknown as NDKEvent;
      const state = store.getState();
      // Add event to the store
      act(() => {
        state.addEvent(event);
      });
      // Events should not be updated yet because of buffering
      expect(state.events.length).toBe(0);
      // Advance timer to trigger the buffer flush
      act(() => {
        vi.advanceTimersByTime(30);
      });
      // After buffer time, events should be updated
      expect(state.events.length).toBe(1);
      expect(state.events[0]).toBe(event);
    });
    it('should update events immediately when buffering is disabled', () => {
      const storeWithoutBuffer = createSubscribeStore<NDKEvent>(false);
      const state = storeWithoutBuffer.getState();
      const event = new MockEvent() as unknown as NDKEvent;
      act(() => {
        state.addEvent(event);
      });
      // Events should be updated immediately without buffering
      expect(state.events.length).toBe(1);
      expect(state.events[0]).toBe(event);
    });
    it('should not add older events of the same ID when buffering is enabled', () => {
      const state = store.getState();
      const event1 = new MockEvent({ id: 'test-id', created_at: 1000 }) as unknown as NDKEvent;
      const event2 = new MockEvent({ id: 'test-id', created_at: 500 }) as unknown as NDKEvent; // Older event
      act(() => {
        state.addEvent(event1);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events.length).toBe(1);
      expect(state.events[0]).toBe(event1);
      act(() => {
        state.addEvent(event2);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      // Should still have only event1 (newer event)
      expect(state.events.length).toBe(1);
      expect(state.events[0]).toBe(event1);
    });
  });
  describe('event mapping and sorting', () => {
    it('should map events by their ID', () => {
      const state = store.getState();
      const event = new MockEvent({ id: 'test-id' }) as unknown as NDKEvent;
      act(() => {
        state.addEvent(event);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.eventMap.size).toBe(1);
      expect(state.eventMap.get('test-id')).toBe(event);
    });
    it('should replace events with newer versions when using the same ID', () => {
      const state = store.getState();
      const olderEvent = new MockEvent({ id: 'test-id', created_at: 1000, content: 'old content' }) as unknown as NDKEvent;
      const newerEvent = new MockEvent({ id: 'test-id', created_at: 2000, content: 'new content' }) as unknown as NDKEvent;
      act(() => {
        state.addEvent(olderEvent);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events[0].content).toBe('old content');
      act(() => {
        state.addEvent(newerEvent);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events.length).toBe(1);
      expect(state.events[0].content).toBe('new content');
    });
    it('should keep older events when newer events with same ID are added', () => {
      const state = store.getState();
      const newerEvent = new MockEvent({ id: 'test-id', created_at: 2000, content: 'new content' }) as unknown as NDKEvent;
      const olderEvent = new MockEvent({ id: 'test-id', created_at: 1000, content: 'old content' }) as unknown as NDKEvent;
      act(() => {
        state.addEvent(newerEvent);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events[0].content).toBe('new content');
      act(() => {
        state.addEvent(olderEvent);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events.length).toBe(1);
      expect(state.events[0].content).toBe('new content');
    });
  });
  describe('EOSE handling', () => {
    it('should set eose flag when setEose is called', () => {
      const state = store.getState();
      expect(state.eose).toBe(false);
      act(() => {
        state.setEose();
      });
      expect(state.eose).toBe(true);
    });
    it('should flush buffer immediately when setEose is called', () => {
      const state = store.getState();
      const event = new MockEvent() as unknown as NDKEvent;
      act(() => {
        state.addEvent(event);
      });
      // Buffer not flushed yet
      expect(state.events.length).toBe(0);
      act(() => {
        state.setEose();
      });
      // Buffer should be flushed immediately on EOSE
      expect(state.events.length).toBe(1);
      expect(state.eose).toBe(true);
    });
  });
  describe('reset functionality', () => {
    it('should clear all events and reset flags when reset is called', () => {
      const state = store.getState();
      const event = new MockEvent() as unknown as NDKEvent;
      // Add an event and set EOSE
      act(() => {
        state.addEvent(event);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      act(() => {
        state.setEose();
      });
      expect(state.events.length).toBe(1);
      expect(state.eose).toBe(true);
      // Reset the store
      act(() => {
        state.reset();
      });
      // Store should be empty after reset
      expect(state.events.length).toBe(0);
      expect(state.eventMap.size).toBe(0);
      expect(state.eose).toBe(false);
      expect(state.isSubscribed).toBe(false);
      expect(state.subscriptionRef).toBeUndefined();
    });
    it('should set subscriptionRef and update isSubscribed flag', () => {
      const state = store.getState();
      const mockSub = createMockSubscription();
      expect(state.isSubscribed).toBe(false);
      expect(state.subscriptionRef).toBeUndefined();
      act(() => {
        state.setSubscription(mockSub);
      });
      expect(state.isSubscribed).toBe(true);
      expect(state.subscriptionRef).toBe(mockSub);
      act(() => {
        state.setSubscription(undefined);
      });
      expect(state.isSubscribed).toBe(false);
      expect(state.subscriptionRef).toBeUndefined();
    });
  });
  describe('removeEventId', () => {
    it('should remove an event by ID', () => {
      const state = store.getState();
      const event1 = new MockEvent({ id: 'test-id-1' }) as unknown as NDKEvent;
      const event2 = new MockEvent({ id: 'test-id-2' }) as unknown as NDKEvent;
      act(() => {
        state.addEvent(event1);
        state.addEvent(event2);
      });
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(state.events.length).toBe(2);
      act(() => {
        state.removeEventId('test-id-1');
      });
      expect(state.events.length).toBe(1);
      expect(state.eventMap.has('test-id-1')).toBe(false);
      expect(state.eventMap.has('test-id-2')).toBe(true);
    });
  });
});
describe('Subscribe Hook', () => {
  let mockNDK: NDK;
  let mockFilters: NDKFilter[];
  let mockSubscription: NDKSubscription;
  beforeEach(() => {
    // Setup mocks
    mockNDK = {
      subscribe: vi.fn(),
    } as unknown as NDK;
    mockFilters = [{ kinds: [1], limit: 10 }];
    mockSubscription = {
      on: vi.fn(),
      off: vi.fn(),
      stop: vi.fn(),
      start: vi.fn(() => []),
      events: [] as NDKEvent[],
      eose: false
    } as unknown as NDKSubscription;
    (mockNDK.subscribe as any).mockReturnValue(mockSubscription);
    // Mock useNDK hook
    (useNDK as any).mockReturnValue({ ndk: mockNDK });
    vi.useFakeTimers();
  });
  afterEach(() => {
    vi.useRealTimers();
    vi.clearAllMocks();
  });
  describe('basic subscription functionality', () => {
    it('should not subscribe if filters are empty', () => {
      const { result } = renderHook(() => useSubscribe([]));
      expect(mockNDK.subscribe).not.toHaveBeenCalled();
      expect(result.current.isSubscribed).toBe(false);
    });
    it('should not subscribe if NDK is not initialized', () => {
      (useNDK as any).mockReturnValue({ ndk: undefined });
      const { result } = renderHook(() => useSubscribe(mockFilters));
      expect(result.current.isSubscribed).toBe(false);
    });
    it('should subscribe with the provided filters when NDK is initialized', () => {
      const { result } = renderHook(() => useSubscribe(mockFilters));
      expect(mockNDK.subscribe).toHaveBeenCalledWith(mockFilters, {}, undefined, false);
      expect(mockSubscription.start).toHaveBeenCalledWith(false);
      expect(result.current.isSubscribed).toBe(true);
    });
    it('should clean up subscription when component unmounts', () => {
      const { unmount } = renderHook(() => useSubscribe(mockFilters));
      unmount();
      expect(mockSubscription.stop).toHaveBeenCalled();
    });
  });
  describe('event handling', () => {
    it('should register event handlers on subscription', () => {
      renderHook(() => useSubscribe(mockFilters));
      expect(mockSubscription.on).toHaveBeenCalledWith('event', expect.any(Function));
      expect(mockSubscription.on).toHaveBeenCalledWith('eose', expect.any(Function));
      expect(mockSubscription.on).toHaveBeenCalledWith('closed', expect.any(Function));
    });
    it('should handle incoming events and update state', () => {
      // Prepare to capture the event handler
      let capturedEventHandler: Function | null = null;
      (mockSubscription.on as any).mockImplementation((event: string, handler: Function) => {
        if (event === 'event') {
          capturedEventHandler = handler;
        }
      });
      const { result } = renderHook(() => useSubscribe(mockFilters));
      // Now trigger an event
      const testEvent = new MockEvent() as unknown as NDKEvent;
      if (capturedEventHandler !== null) {
        act(() => {
          capturedEventHandler!(testEvent);
        });
      }
      // Advance timers to flush buffer
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(result.current.events.length).toBe(1);
      expect(result.current.events[0]).toBe(testEvent);
    });
    it('should handle EOSE event', () => {
      // Prepare to capture the EOSE handler
      let capturedEoseHandler: Function | null = null;
      (mockSubscription.on as any).mockImplementation((event: string, handler: Function) => {
        if (event === 'eose') {
          capturedEoseHandler = handler;
        }
      });
      const { result } = renderHook(() => useSubscribe(mockFilters));
      expect(result.current.eose).toBe(false);
      // Trigger EOSE
      if (capturedEoseHandler !== null) {
        act(() => {
          capturedEoseHandler!();
        });
      }
      expect(result.current.eose).toBe(true);
    });
    it('should handle closed event', () => {
      // Prepare to capture the closed handler
      let capturedClosedHandler: Function | null = null;
      (mockSubscription.on as any).mockImplementation((event: string, handler: Function) => {
        if (event === 'closed') {
          capturedClosedHandler = handler;
        }
      });
      const { result } = renderHook(() => useSubscribe(mockFilters));
      expect(result.current.isSubscribed).toBe(true);
      // Trigger closed
      if (capturedClosedHandler !== null) {
        act(() => {
          capturedClosedHandler!();
        });
      }
      expect(result.current.isSubscribed).toBe(false);
    });
  });
  describe('handling of cached events', () => {
    it('should process cached events from subscription.start', () => {
      // Setup mock cached events
      const cachedEvent1 = new MockEvent() as unknown as NDKEvent;
      const cachedEvent2 = new MockEvent() as unknown as NDKEvent;
      const cachedEvents = [cachedEvent1, cachedEvent2];
      (mockSubscription.start as any).mockReturnValue(cachedEvents);
      const { result } = renderHook(() => useSubscribe(mockFilters));
      // Advance timers to flush buffer
      act(() => {
        vi.advanceTimersByTime(30);
      });
      expect(result.current.events.length).toBe(2);
      expect(result.current.events).toContain(cachedEvent1);
      expect(result.current.events).toContain(cachedEvent2);
    });
  });
  describe('relay set creation', () => {
    it('should create relay set from provided relay URLs', () => {
      const relayUrls = ['wss://relay1.example.com', 'wss://relay2.example.com'];
      renderHook(() => useSubscribe(mockFilters, { relays: relayUrls }));
      expect(NDKRelaySet.fromRelayUrls).toHaveBeenCalledWith(relayUrls, mockNDK);
      expect(mockNDK.subscribe).toHaveBeenCalledWith(
        mockFilters,
        { relays: relayUrls },
        expect.anything(),
        false
      );
    });
    it('should not create relay set if no relay URLs provided', () => {
      renderHook(() => useSubscribe(mockFilters));
      expect(NDKRelaySet.fromRelayUrls).not.toHaveBeenCalled();
      expect(mockNDK.subscribe).toHaveBeenCalledWith(
        mockFilters,
        {},
        undefined,
        false
      );
    });
  });
  describe('dependency handling', () => {
    it('should resubscribe when dependencies change', () => {
      const { rerender } = renderHook(
        ({ deps }) => useSubscribe(mockFilters, {}, deps),
        { initialProps: { deps: ['initial'] } }
      );
      // Initial subscription
      expect(mockNDK.subscribe).toHaveBeenCalledTimes(1);
      // Change dependencies and rerender
      rerender({ deps: ['changed'] });
      // Should stop old subscription and create a new one
      expect(mockSubscription.stop).toHaveBeenCalledTimes(1);
      expect(mockNDK.subscribe).toHaveBeenCalledTimes(2);
    });
    it('should not resubscribe if filters change to false', () => {
      // Start with valid filters
      const { rerender } = renderHook(
        ({ useFilters }) => useSubscribe(useFilters ? mockFilters : false),
        { initialProps: { useFilters: true } }
      );
      // Initial subscription
      expect(mockNDK.subscribe).toHaveBeenCalledTimes(1);
      // Change filters to false
      rerender({ useFilters: false });
      // Should stop old subscription but not create a new one
      expect(mockSubscription.stop).toHaveBeenCalled();
      expect(mockNDK.subscribe).toHaveBeenCalledTimes(1);
    });
  });
});
</file>

<file path=".biomeignore">
node_modules/
dist/
.turbo/
coverage/
*.d.ts
</file>

<file path=".gitignore">
# Dependency directories
node_modules/
.pnp/
.pnp.js

# Build and output directories
dist/
build/
out/
.next/
.nuxt/

# Coverage directories
coverage/
.nyc_output/

# Log files
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Environment variables and secrets
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.idea/
.vscode/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.DS_Store

# Cache directories
.npm/
.eslintcache
.prettiercache
.biomecache/

# TypeScript
*.tsbuildinfo
</file>

<file path=".roomodes">
{
  "customModes": [
    {
      "slug": "sparc",
      "name": "⚡️ SPARC Orchestrator",
      "roleDefinition": "You are SPARC, the orchestrator of complex workflows. You break down large objectives into delegated subtasks aligned to the SPARC methodology. You ensure secure, modular, testable, and maintainable delivery using the appropriate specialist modes.",
      "customInstructions": "Follow SPARC:\n\n1. Specification: Clarify objectives and scope. Never allow hard-coded env vars.\n2. Pseudocode: Request high-level logic with TDD anchors.\n3. Architecture: Ensure extensible system diagrams and service boundaries.\n4. Refinement: Use TDD, debugging, security, and optimization flows.\n5. Completion: Integrate, document, and monitor for continuous improvement.\n\nUse `new_task` to assign:\n- spec-pseudocode\n- architect\n- code\n- tdd\n- debug\n- docs-writer\n- integration\n- refinement-optimization-mode\n\nValidate:\n✅ Files < 500 lines\n✅ No hard-coded env vars\n✅ Modular, testable outputs\n✅ All subtasks end with `attempt_completion` Initialize when any request is received with a brief welcome mesage. Use emojis to make it fun and engaging. Always remind users to keep their requests modular, avoid hardcoding secrets, and use `attempt_completion` to finalize tasks. When you finish or when you have questions, send me a notification using the mcp tool.",
      "groups": [],
      "source": "project"
    },
    {
      "slug": "spec-pseudocode",
      "name": "📋 Specification Writer",
      "roleDefinition": "You capture full project context—functional requirements, edge cases, constraints—and translate that into modular pseudocode with TDD anchors.",
      "customInstructions": "Write pseudocode and flow logic that includes clear structure for future coding and testing. Split complex logic across modules. Never include hard-coded secrets or config values. Ensure each spec module remains < 500 lines.",
      "groups": ["read", "edit"],
      "source": "project"
    },
    {
      "slug": "architect",
      "name": "🏗️ Architect",
      "roleDefinition": "You design scalable, secure, and modular architectures based on functional specs and user needs. You define responsibilities across services, APIs, and components.",
      "customInstructions": "Create architecture mermaid diagrams, data flows, and integration points. Ensure no part of the design includes secrets or hardcoded env values. Emphasize modular boundaries and maintain extensibility. All descriptions and diagrams must fit within a single file or modular folder.",
      "groups": ["read"],
      "source": "project"
    },
    {
      "slug": "code",
      "name": "🧠 Auto-Coder",
      "roleDefinition": "You write clean, efficient, modular code based on pseudocode and architecture. You use configuration for environments and break large components into maintainable files.",
      "customInstructions": "Write modular code using clean architecture principles. Never hardcode secrets or environment values. Split code into files < 500 lines. Use config files or environment abstractions. Use `new_task` for subtasks and finish with `attempt_completion`. Never use nostr-tools, NDK provides you everything you need.",
      "groups": ["read", "edit", "browser", "mcp", "command"],
      "source": "project"
    },
    {
      "slug": "tdd",
      "name": "🧪 Tester (TDD)",
      "roleDefinition": "You implement Test-Driven Development (TDD, London School), writing tests first and refactoring after minimal implementation passes.",
      "customInstructions": "Write failing tests first. Implement only enough code to pass. Refactor after green. Ensure tests do not hardcode secrets. Keep files < 500 lines. Validate modularity, test coverage, and clarity before using `attempt_completion`. Never mock or use nostr-tools.",
      "groups": ["read", "edit", "browser", "mcp", "command"],
      "source": "project"
    },
    {
      "slug": "debug",
      "name": "🪲 Debugger",
      "roleDefinition": "You troubleshoot runtime bugs, logic errors, or integration failures by tracing, inspecting, and analyzing behavior.",
      "customInstructions": "Use logs, traces, and stack analysis to isolate bugs. Avoid changing env configuration directly. Keep fixes modular. Refactor if a file exceeds 500 lines. Use `new_task` to delegate targeted fixes and return your resolution via `attempt_completion`.",
      "groups": ["read", "edit", "browser", "mcp", "command"],
      "source": "project"
    },
    {
      "slug": "docs-writer",
      "name": "📚 Documentation Writer",
      "roleDefinition": "You write concise, clear, and modular Markdown documentation that explains usage, integration, setup, and configuration.",
      "customInstructions": "Only work in .md files. Use sections, examples, and headings. Keep each file under 500 lines. Do not leak env values. Summarize what you wrote using `attempt_completion`. Delegate large guides with `new_task`.",
      "groups": [
        "read",
        [
          "edit",
          {
            "fileRegex": "\\.md$",
            "description": "Markdown files only"
          }
        ]
      ],
      "source": "project"
    },
    {
      "slug": "integration",
      "name": "🔗 System Integrator",
      "roleDefinition": "You merge the outputs of all modes into a working, tested, production-ready system. You ensure consistency, cohesion, and modularity.",
      "customInstructions": "Verify interface compatibility, shared modules, and env config standards. Split integration logic across domains as needed. Use `new_task` for preflight testing or conflict resolution. End integration tasks with `attempt_completion` summary of what’s been connected.",
      "groups": ["read", "edit", "browser", "mcp", "command"],
      "source": "project"
    },
    {
      "slug": "refinement-optimization-mode",
      "name": "🧹 Optimizer",
      "roleDefinition": "You refactor, modularize, and improve system performance. You enforce file size limits, dependency decoupling, and configuration hygiene.",
      "customInstructions": "Audit files for clarity, modularity, and size. Break large components (>500 lines) into smaller ones. Move inline configs to env files. Optimize performance or structure. Use `new_task` to delegate changes and finalize with `attempt_completion`.",
      "groups": ["read", "edit", "browser", "mcp", "command"],
      "source": "project"
    },
    {
      "slug": "ask",
      "name": "❓Ask",
      "roleDefinition": "You are a task-formulation guide that helps users navigate, ask, and delegate tasks to the correct SPARC modes.",
      "customInstructions": "Guide users to ask questions using SPARC methodology:\n\n• 📋 `spec-pseudocode` – logic plans, pseudocode, flow outlines\n• 🏗️ `architect` – system diagrams, API boundaries\n• 🧠 `code` – implement features with env abstraction\n• 🧪 `tdd` – test-first development, coverage tasks\n• 🪲 `debug` – isolate runtime issues\n• 🛡️ `security-review` – check for secrets, exposure\n• 📚 `docs-writer` – create markdown guides\n• 🔗 `integration` – link services, ensure cohesion\n• 📈 `post-deployment-monitoring-mode` – observe production\n• 🧹 `refinement-optimization-mode` – refactor & optimize\n\nHelp users craft `new_task` messages to delegate effectively, and always remind them:\n✅ Modular\n✅ Env-safe\n✅ Files < 500 lines\n✅ Use `attempt_completion`",
      "groups": ["read"],
      "source": "project"
    },
      {
        "slug": "tutorial",
        "name": "📘 SPARC Tutorial",
        "roleDefinition": "You are the SPARC onboarding and education assistant. Your job is to guide users through the full SPARC development process using structured thinking models. You help users understand how to navigate complex projects using the specialized SPARC modes and properly formulate tasks using new_task.",
        "customInstructions": "You teach developers how to apply the SPARC methodology through actionable examples and mental models.\n\n🎯 **Your goals**:\n• Help new users understand how to begin a SPARC-mode-driven project.\n• Explain how to modularize work, delegate tasks with `new_task`, and validate using `attempt_completion`.\n• Ensure users follow best practices like:\n  - No hard-coded environment variables\n  - Files under 500 lines\n  - Clear mode-to-mode handoffs\n\n🧠 **Thinking Models You Encourage**:\n\n1. **SPARC Orchestration Thinking** (for `sparc`):\n   - Break the problem into logical subtasks.\n   - Map to modes: specification, coding, testing, security, docs, integration, deployment.\n   - Think in layers: interface vs. implementation, domain logic vs. infrastructure.\n\n2. **Architectural Systems Thinking** (for `architect`):\n   - Focus on boundaries, flows, contracts.\n   - Consider scale, fault tolerance, security.\n   - Use mermaid diagrams to visualize services, APIs, and storage.\n\n3. **Prompt Decomposition Thinking** (for `ask`):\n   - Translate vague problems into targeted prompts.\n   - Identify which mode owns the task.\n   - Use `new_task` messages that are modular, declarative, and goal-driven.\n\n📋 **Example onboarding flow**:\n\n- Ask: “Build a new onboarding flow with SSO.”\n- Ask Agent (`ask`): Suggest decomposing into spec-pseudocode, architect, code, tdd, docs-writer, and integration.\n- SPARC Orchestrator (`sparc`): Issues `new_task` to each with scoped instructions.\n- All responses conclude with `attempt_completion` and a concise, structured result summary.\n\n📌 Reminders:\n✅ Modular task structure\n✅ Secure env management\n✅ Delegation with `new_task`\n✅ Concise completions via `attempt_completion`\n✅ Mode awareness: know who owns what\n\nYou are the first step to any new user entering the SPARC system.",
        "groups": ["read"],
        "source": "project"
      }      
  ]
}
</file>

<file path="biome.json">
{
    "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
    "organizeImports": {
        "enabled": true
    },
    "linter": {
        "enabled": true,
        "rules": {
            "recommended": true
        }
    },
    "formatter": {
        "enabled": true,
        "indentStyle": "space",
        "indentWidth": 4
    },
    "javascript": {
        "formatter": {
            "quoteStyle": "single",
            "trailingCommas": "es5",
            "semicolons": "always"
        }
    }
}
</file>

<file path="package.json">
{
    "name": "@nostr-dev-kit/ndk-hooks",
    "version": "0.1.0",
    "private": false,
    "description": "React hooks for the Nostr Development Kit (NDK)",
    "main": "dist/index.js",
    "module": "dist/index.mjs",
    "types": "dist/types/index.d.ts",
    "files": [
        "dist",
        "README.md"
    ],
    "scripts": {
        "build": "tsup src/index.ts --format cjs,esm --dts --clean",
        "dev": "tsup src/index.ts --format cjs,esm --watch",
        "lint": "biome check .",
        "format": "biome check . --write",
        "test": "vitest run",
        "test:watch": "vitest",
        "prepare": "pnpm run build"
    },
    "peerDependencies": {
        "@nostr-dev-kit/ndk": "^2.13",
        "zustand": "^5",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0"
    },
    "devDependencies": {
        "@nostr-dev-kit/ndk": "workspace:*",
        "@nostr-dev-kit/ndk-test-utils": "workspace:*",
        "@testing-library/react-hooks": "^8.0.1",
        "@types/react": "^18.2.67",
        "biome": "^0.3.3",
        "react": "^18.2.0",
        "react-test-renderer": "^18.2.0",
        "tsup": "^8.0.2",
        "typescript": "^5.4.3",
        "vitest": "^1.4.0",
        "zustand": "^5.0.3"
    },
    "keywords": [
        "nostr",
        "ndk",
        "react",
        "hooks"
    ],
    "author": "_@f7z.io",
    "license": "MIT"
}
</file>

<file path="README.md">
# @nostr-dev-kit/ndk-hooks

> React hooks for the Nostr Development Kit (NDK)

## Overview

`@nostr-dev-kit/ndk-hooks` provides a set of React hooks and utilities to easily integrate Nostr functionality into your React applications using NDK. This library helps you efficiently manage Nostr data in your React components, including:

- NDK instance management with `useNDK`
- Current user management with `useNDKCurrentUser`
- User profile management with `useProfile`

## Installation

```bash
# npm
npm install @nostr-dev-kit/ndk-hooks

# pnpm
pnpm add @nostr-dev-kit/ndk-hooks

# yarn
yarn add @nostr-dev-kit/ndk-hooks
```

## Requirements

- React 16.8.0 or higher
- @nostr-dev-kit/ndk ^2.13
- zustand ^5

## Usage

### NDK Store and Hooks

#### Setting Up NDK Instance

First, initialize the NDK instance and make it available to your components:

```tsx
import NDK from '@nostr-dev-kit/ndk';
import { useNDK } from '@nostr-dev-kit/ndk-hooks';

function App() {
  const { setNDK } = useNDK();
  
  useEffect(() => {
    const ndk = new NDK({
      explicitRelayUrls: ['wss://relay.nostr.band', 'wss://relay.damus.io'],
    });
    
    ndk.connect().then(() => {
      setNDK(ndk);
    });
  }, [setNDK]);
  
  return <YourApp />;
}
```

#### Accessing Current User

You can access and set the current user with `useNDKCurrentUser`:

```tsx
import { useNDKCurrentUser } from '@nostr-dev-kit/ndk-hooks';

function UserProfile() {
  const { currentUser } = useNDKCurrentUser();
  
  if (!currentUser) {
    return <div>Not logged in</div>;
  }
  
  return (
    <div>
      <h2>Logged in as: {currentUser.pubkey}</h2>
      {/* Display user information */}
    </div>
  );
}
```

For more details on NDK store and hooks, see the [NDK Hooks Documentation](docs/ndk-hooks.md).

### User Profile Management

Before using the profile hooks, you need to initialize the profiles store with your NDK instance:

```tsx
import NDK from '@nostr-dev-kit/ndk';
import { useUserProfilesStore } from '@nostr-dev-kit/ndk-hooks';

// During app initialization
const ndk = new NDK({
  explicitRelayUrls: ['wss://relay.nostr.band', 'wss://relay.damus.io'],
});

await ndk.connect();

// Initialize the profiles store
useUserProfilesStore.getState().initialize(ndk);
```

### Getting a User Profile

Use the `useProfile` hook to fetch and display user profiles:

```tsx
import { useProfile } from '@nostr-dev-kit/ndk-hooks';

function UserCard({ pubkey }) {
  const profile = useProfile(pubkey);

  if (!profile) {
    return <div>Loading profile...</div>;
  }

  return (
    <div>
      <img src={profile.picture} alt={profile.name} />
      <h2>{profile.name || 'Anonymous'}</h2>
      <p>{profile.about}</p>
    </div>
  );
}
```

### Forcing a Profile Refresh

You can force a profile to be refreshed from the network by passing `true` as the second parameter:

```tsx
// This will fetch the profile from the network even if it's cached
const profile = useProfile(pubkey, true);
```

### Directly Accessing the Store

You can directly interact with the underlying Zustand store:

```tsx
import { useUserProfilesStore } from '@nostr-dev-kit/ndk-hooks';

// Set a profile manually
useUserProfilesStore.getState().setProfile(pubkey, profile);

// Fetch a profile manually
useUserProfilesStore.getState().fetchProfile(pubkey);

// Get all profiles
const profiles = useUserProfilesStore.getState().profiles;
```

## API Reference

### NDK Hooks

#### `useNDK(): { ndk: NDK | null, setNDK: (ndk: NDK) => void }`

Provides access to the NDK instance and a function to set it.

- `ndk` - The current NDK instance or null if not set
- `setNDK` - Function to set the NDK instance

#### `useNDKCurrentUser(): { currentUser: NDKUser | null, setCurrentUser: (user: NDKUser | null) => void }`

Provides access to the current user and a function to set it.

- `currentUser` - The current user or null if not logged in
- `setCurrentUser` - Function to set the current user

### Profile Hooks

#### `useProfile(pubkey: string, forceRefresh?: boolean): NDKUserProfile | undefined`

Fetches and returns a Nostr user profile for the given pubkey.

- `pubkey` - The hex pubkey of the user
- `forceRefresh` - (Optional) Whether to force a refresh of the profile from the network
- Returns: The user profile object or undefined if not loaded yet

### Store API

#### `useUserProfilesStore`

A Zustand store that manages user profiles.

Properties:
- `profiles` - Map of pubkeys to profile objects
- `lastFetchedAt` - Map of pubkeys to timestamps of last fetch
- `ndk` - The NDK instance

Methods:
- `initialize(ndk: NDK)` - Initialize the store with an NDK instance
- `setProfile(pubkey: string, profile: NDKUserProfile, cachedAt?: number)` - Manually set a profile
- `fetchProfile(pubkey?: string, force?: boolean)` - Fetch a profile from the network

## License

MIT
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "declaration": true,
    "declarationDir": "./dist/types",
    "outDir": "./dist",
    "rootDir": "./src",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.test.tsx"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
export default defineConfig({
    test: {
        environment: 'jsdom',
        globals: true,
        setupFiles: ['./test/setup.ts'],
    },
});
</file>

</files>
