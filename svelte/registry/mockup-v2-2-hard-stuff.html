<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>We Solved The Hard Stuff</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: #fff;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }

        .hero {
            padding: 100px 0 80px;
            text-align: center;
            border-bottom: 1px solid #e5e5e5;
        }
        .hero h1 {
            font-size: 52px;
            font-weight: 700;
            margin-bottom: 24px;
            letter-spacing: -0.02em;
        }
        .hero .subtitle {
            font-size: 20px;
            color: #666;
            max-width: 800px;
            margin: 0 auto;
        }

        .section {
            padding: 80px 0;
        }
        .section h2 {
            font-size: 36px;
            margin-bottom: 20px;
            font-weight: 700;
        }
        .section .intro {
            font-size: 18px;
            color: #666;
            margin-bottom: 40px;
            max-width: 800px;
        }

        .problem-solution {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 60px;
        }
        .problem {
            background: #fafafa;
            border-left: 4px solid #999;
            padding: 32px;
            border-radius: 6px;
        }
        .problem h3 {
            color: #999;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 16px;
        }
        .problem .content {
            color: #666;
            line-height: 1.8;
            margin-bottom: 20px;
        }
        .problem-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .problem-item {
            font-size: 14px;
            color: #999;
            padding-left: 20px;
            position: relative;
        }
        .problem-item::before {
            content: '×';
            position: absolute;
            left: 0;
            font-weight: 700;
        }

        .solution {
            background: #fff;
            border: 2px solid #1a1a1a;
            border-left: 4px solid #1a1a1a;
            padding: 32px;
            border-radius: 6px;
        }
        .solution h3 {
            color: #1a1a1a;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 16px;
        }
        .solution .content {
            color: #333;
            line-height: 1.8;
            margin-bottom: 20px;
        }

        .code {
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            border-radius: 4px;
            font-family: 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.8;
            overflow-x: auto;
        }
        .code .comment { color: #888; }
        .code .tag { color: #50fa7b; }

        .showcase {
            background: #fafafa;
            border: 2px solid #e5e5e5;
            padding: 40px;
            border-radius: 8px;
            margin-bottom: 40px;
        }
        .showcase h3 {
            font-size: 24px;
            margin-bottom: 24px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 32px;
        }
        .feature {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            padding: 28px;
            border-radius: 6px;
        }
        .feature h4 {
            font-size: 18px;
            margin-bottom: 12px;
            font-weight: 600;
        }
        .feature p {
            color: #666;
            line-height: 1.7;
            font-size: 15px;
            margin-bottom: 16px;
        }
        .feature .tech {
            font-size: 13px;
            color: #999;
            font-family: 'Monaco', monospace;
        }

        .visual {
            background: #fff;
            border: 1px solid #e5e5e5;
            padding: 24px;
            border-radius: 4px;
            margin-top: 16px;
        }
        .visual pre {
            font-family: 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            color: #666;
        }

        .bg-alt { background: #f5f5f5; }
    </style>
</head>
<body>
    <section class="hero">
        <div class="container">
            <h1>We Solved<br>The Hard Stuff</h1>
            <p class="subtitle">
                Thread reconstruction. Custom emoji rendering everywhere. Negentropy sync.
                Highlight extraction. NIP-99 product cards. The complex problems you don't want to solve yourself.
            </p>
        </div>
    </section>

    <section class="section">
        <div class="container">
            <h2>Thread Reconstruction</h2>
            <p class="intro">
                Nostr events don't come with tree structures. They're flat. Building Twitter-like
                conversations means recursively fetching replies, handling missing events, managing depth...
            </p>

            <div class="problem-solution">
                <div class="problem">
                    <h3>The Problem</h3>
                    <div class="content">
                        Events reference parents via 'e' tags. You fetch an event, find its parent tag,
                        fetch that event, find ITS parent... recursive fetching, infinite loops, missing events,
                        building tree structures, handling deleted events.
                    </div>
                    <div class="problem-list">
                        <div class="problem-item">Recursive relay queries</div>
                        <div class="problem-item">Circular reference handling</div>
                        <div class="problem-item">Missing event gaps</div>
                        <div class="problem-item">Tree structure building</div>
                        <div class="problem-item">Depth tracking</div>
                        <div class="problem-item">Performance with 100+ replies</div>
                    </div>
                </div>

                <div class="solution">
                    <h3>The Solution</h3>
                    <div class="content">
                        createEventThread handles all of it. Pass the root event. Get back a reactive tree
                        structure with depth indicators, missing event handling, and efficient caching.
                    </div>
                    <div class="code">
<span class="comment">// Build complete thread tree</span>
const thread = createEventThread(() => ({
  rootEvent: event
}));

<span class="comment">// Reactive tree structure</span>
$: rootNode = thread.root;
$: allReplies = thread.replies;

<span class="comment">// Render the tree</span>
<span class="tag">&lt;ThreadView</span> {thread} <span class="tag">/&gt;</span>

<span class="comment">// Handles: recursive fetching, circular refs,</span>
<span class="comment">// missing events, depth tracking, caching</span>
                    </div>
                </div>
            </div>

            <div class="showcase">
                <h3>What You Get</h3>
                <div class="visual">
                    <pre>
Root Event (depth: 0)
├── Reply A (depth: 1)
│   ├── Reply A1 (depth: 2)
│   └── Reply A2 (depth: 2)
├── Reply B (depth: 1)
│   └── Reply B1 (depth: 2)
│       └── Reply B1a (depth: 3)
└── Reply C (depth: 1)

Missing events: [event_id_xyz] (shown with placeholder)
Circular refs: Detected and broken
Updates: Real-time as new replies arrive</pre>
                </div>
            </div>
        </div>
    </section>

    <section class="section bg-alt">
        <div class="container">
            <h2>Custom Emoji Rendering (NIP-30)</h2>
            <p class="intro">
                Custom emojis aren't just images. They need to render in content, in reactions,
                in the emoji picker, with fallbacks, with the right size for context...
            </p>

            <div class="problem-solution">
                <div class="problem">
                    <h3>The Problem</h3>
                    <div class="content">
                        NIP-30 custom emojis have URLs. Where do you render them? In note content when someone uses :customemoji:?
                        In reactions when someone reacts with it? In the picker? Different sizes? Fallbacks when URL fails?
                    </div>
                    <div class="problem-list">
                        <div class="problem-item">Parse :emoji: syntax in content</div>
                        <div class="problem-item">Render in reactions AND content</div>
                        <div class="problem-item">Size variations (inline vs display)</div>
                        <div class="problem-item">Failed URL fallbacks</div>
                        <div class="problem-item">Picker integration</div>
                        <div class="problem-item">Emoji pack management</div>
                    </div>
                </div>

                <div class="solution">
                    <h3>The Solution</h3>
                    <div class="content">
                        Content renderer handles custom emoji parsing. Reaction components use the same
                        renderer. Emoji picker is aware of custom packs. Everything consistent.
                    </div>
                    <div class="code">
<span class="comment">// Define custom emoji pack</span>
const customEmojis = {
  'party': 'https://cdn.../party.png',
  'rocket': 'https://cdn.../rocket.png'
};

<span class="comment">// Renders in content automatically</span>
<span class="tag">&lt;Event.Content</span>
  {event}
  {customEmojis}
<span class="tag">/&gt;</span>
<span class="comment">// "Love this :party:" → renders image</span>

<span class="comment">// Same emojis in reactions</span>
<span class="tag">&lt;ReactionButton</span>
  {event}
  {customEmojis}
  picker={true}
<span class="tag">/&gt;</span>
<span class="comment">// Picker shows custom emojis too</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="section">
        <div class="container">
            <h2>Negentropy Sync</h2>
            <p class="intro">
                Syncing 10,000 events from a relay? Doing it naively means downloading all 10k.
                Negentropy protocol does set reconciliation. It's complex. We implemented it.
            </p>

            <div class="problem-solution">
                <div class="problem">
                    <h3>The Problem</h3>
                    <div class="content">
                        You have 9,000 events cached. The relay has 10,000. Naive approach: download all 10k,
                        dedupe locally. Negentropy approach: Set reconciliation protocol to download only the
                        1,000 new ones. But implementing Negentropy is... not trivial.
                    </div>
                    <div class="problem-list">
                        <div class="problem-item">Set reconciliation math</div>
                        <div class="problem-item">Fingerprint generation</div>
                        <div class="problem-item">Range splitting</div>
                        <div class="problem-item">Batch processing</div>
                        <div class="problem-item">Progress tracking</div>
                        <div class="problem-item">Error recovery</div>
                    </div>
                </div>

                <div class="solution">
                    <h3>The Solution</h3>
                    <div class="content">
                        createNegentropySyncManager handles the entire protocol. Efficient sync with visual
                        progress, smart batching, and automatic error recovery.
                    </div>
                    <div class="code">
<span class="comment">// Sync large dataset efficiently</span>
const sync = createNegentropySyncManager({
  filter: { kinds: [1], authors: [...] },
  relays: userRelays
});

<span class="comment">// Show progress</span>
<span class="tag">&lt;NegentropySyncAnimated</span> manager={sync} <span class="tag">/&gt;</span>

<span class="comment">// Reactive stats</span>
$: progress = sync.progress;
$: total = sync.totalEvents;
$: synced = sync.syncedEvents;

<span class="comment">// Syncs only what's new. Handles 100k+ events.</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="section bg-alt">
        <div class="container">
            <h2>Content Parsing With Nostr Extensions</h2>
            <p class="intro">
                Markdown rendering is one thing. Rendering with nostr:npub, nostr:nevent, nostr:naddr
                links that need to be fetched, displayed, and clickable? That's another.
            </p>

            <div class="feature-grid">
                <div class="feature">
                    <h4>npub/nprofile Mentions</h4>
                    <p>
                        Parse nostr:npub1... links, fetch the user profile, render with avatar and name,
                        make clickable.
                    </p>
                    <div class="tech">Handles: npub, nprofile, relay hints</div>
                    <div class="code" style="margin-top: 12px; font-size: 12px; padding: 12px;">
"Follow nostr:npub1abc..."
→ Renders: Follow @username
→ Clickable, shows profile on hover
                    </div>
                </div>

                <div class="feature">
                    <h4>nevent/note Embeds</h4>
                    <p>
                        Parse nostr:nevent1... links, fetch the event, render it inline as a card,
                        handle missing events.
                    </p>
                    <div class="tech">Handles: nevent, note, event cards</div>
                    <div class="code" style="margin-top: 12px; font-size: 12px; padding: 12px;">
"Check out nostr:nevent1..."
→ Renders: Embedded event card
→ Full content visible inline
                    </div>
                </div>

                <div class="feature">
                    <h4>naddr Article Links</h4>
                    <p>
                        Parse nostr:naddr1... links for articles (kind 30023), fetch and render
                        article preview cards.
                    </p>
                    <div class="tech">Handles: naddr, parameterized events</div>
                    <div class="code" style="margin-top: 12px; font-size: 12px; padding: 12px;">
"Read this: nostr:naddr1..."
→ Renders: Article preview card
→ Title, summary, author, image
                    </div>
                </div>

                <div class="feature">
                    <h4>Hashtag Links</h4>
                    <p>
                        Parse #hashtags, make them clickable, optionally show follow button,
                        track hashtag follows separately from user follows.
                    </p>
                    <div class="tech">Handles: #tags, follow state, navigation</div>
                    <div class="code" style="margin-top: 12px; font-size: 12px; padding: 12px;">
"Love #bitcoin #nostr"
→ Renders: Clickable hashtags
→ Follow button on hover
→ Separate follow tracking
                    </div>
                </div>
            </div>

            <div class="showcase" style="margin-top: 40px;">
                <h3>All Working Together In Content</h3>
                <div class="code">
<span class="tag">&lt;Event.Content</span>
  {event}
  renderMention={Mention.Modern}
  renderHashtag={Hashtag.Card}
  renderNevent={EventEmbed}
  renderNaddr={ArticleEmbed}
<span class="tag">/&gt;</span>

<span class="comment">// Content: "Follow nostr:npub1... and check out #bitcoin nostr:nevent1..."</span>
<span class="comment">// Renders:</span>
<span class="comment">// - npub as user card with avatar</span>
<span class="comment">// - #bitcoin as clickable hashtag</span>
<span class="comment">// - nevent as embedded event card</span>
<span class="comment">// All fetched, all reactive, all clickable</span>
                </div>
            </div>
        </div>
    </section>

    <section class="section">
        <div class="container">
            <h2>Highlight Extraction & Inline Rendering</h2>
            <p class="intro">
                Highlights (kind 9802) reference articles. Rendering them means fetching the article,
                finding the highlighted text, showing context, handling missing sources...
            </p>

            <div class="problem-solution">
                <div class="problem">
                    <h3>The Problem</h3>
                    <div class="content">
                        A highlight event contains quoted text and an article reference. To render it well,
                        you need to fetch the article, find where the highlight appears, show surrounding context,
                        handle cases where the article changed or is missing.
                    </div>
                    <div class="problem-list">
                        <div class="problem-item">Fetch source article</div>
                        <div class="problem-item">Find highlight in content</div>
                        <div class="problem-item">Extract surrounding context</div>
                        <div class="problem-item">Handle missing source</div>
                        <div class="problem-item">Link to full article</div>
                        <div class="problem-item">Show in article inline</div>
                    </div>
                </div>

                <div class="solution">
                    <h3>The Solution</h3>
                    <div class="content">
                        HighlightCard components fetch the source, extract context, and render beautifully.
                        When rendering articles, highlights can appear inline at the right position.
                    </div>
                    <div class="code">
<span class="comment">// Standalone highlight</span>
<span class="tag">&lt;HighlightCard.Elegant</span>
  highlight={highlightEvent}
<span class="tag">/&gt;</span>
<span class="comment">// Fetches article, shows context</span>

<span class="comment">// Highlights inline in article</span>
<span class="tag">&lt;ArticleContent</span>
  article={articleEvent}
  showInlineHighlights={true}
<span class="tag">/&gt;</span>
<span class="comment">// Highlights appear at correct positions</span>
<span class="comment">// With "X people highlighted this" info</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="section bg-alt">
        <div class="container">
            <h2>NIP-99 Product Cards</h2>
            <p class="intro">
                Product listings (NIP-99) have prices, images, categories, shipping info.
                Rendering them properly means handling all the metadata, showing images, formatting prices...
            </p>

            <div class="showcase">
                <h3>Product Event → Beautiful Card</h3>
                <div class="code">
<span class="comment">// NIP-99 product event (kind 30018)</span>
const productEvent = {
  kind: 30018,
  content: "Handmade leather wallet",
  tags: [
    ["price", "50", "USD"],
    ["image", "https://..."],
    ["category", "accessories"],
    ["shipping", "worldwide"]
  ]
};

<span class="comment">// Render as product card</span>
<span class="tag">&lt;EventCard</span> event={productEvent} <span class="tag">/&gt;</span>

<span class="comment">// Auto-detects kind 30018</span>
<span class="comment">// Renders: image gallery, price, category tags,</span>
<span class="comment">// shipping info, buy button, merchant info</span>
<span class="comment">// All styled and formatted correctly</span>
                </div>
            </div>
        </div>
    </section>

    <section class="section">
        <div class="container">
            <h2>The Pattern: Hard Problems, Simple APIs</h2>
            <p class="intro">
                We don't hide complexity behind magic. We solve it properly, then expose
                simple, composable APIs that give you control when you need it.
            </p>

            <div class="feature-grid">
                <div class="feature">
                    <h4>Relay Hints From Tags</h4>
                    <p>
                        Events have relay hints in 'e' and 'p' tags. We parse them, use them for fetching,
                        and let you display relay info to users.
                    </p>
                </div>

                <div class="feature">
                    <h4>Event Kind Detection</h4>
                    <p>
                        Pass any event to EventCard. It detects the kind and renders appropriately.
                        No switch statements in your code.
                    </p>
                </div>

                <div class="feature">
                    <h4>Missing Event Handling</h4>
                    <p>
                        Threads have missing replies? Articles reference deleted events? Show placeholders,
                        retry logic, graceful degradation.
                    </p>
                </div>

                <div class="feature">
                    <h4>Real-Time Updates</h4>
                    <p>
                        New replies arrive? Reaction counts change? Zaps come in? Everything updates
                        reactively without polling.
                    </p>
                </div>
            </div>
        </div>
    </section>
</body>
</html>